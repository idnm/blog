<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2021-12-13">
<meta name="description" content="Flexible and efficient learning with JAX+numpy">

<title>Notes on Quantum Computing - Machine learning compilation of quantum circuits – experiments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../kika.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-listing .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-date','listing-title','listing-description','listing-categories','listing-image',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-file-modified-sort'] }],
      
      searchColumns: [],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-listing'] = new List('listing-listing', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1154MLY31V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1154MLY31V', { 'anonymize_ip': true});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Notes on Quantum Computing</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Machine learning compilation of quantum circuits – experiments</h1>
                  <div>
        <div class="description">
          Flexible and efficient learning with JAX+numpy
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">qiskit</div>
                <div class="quarto-category">JAX</div>
                <div class="quarto-category">machine learning</div>
                <div class="quarto-category">compilation</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 13, 2021</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#the-problem" id="toc-the-problem" class="nav-link" data-scroll-target="#the-problem">The problem</a></li>
  <li><a href="#qubit-example" id="toc-qubit-example" class="nav-link" data-scroll-target="#qubit-example">3-qubit example</a></li>
  <li><a href="#what-youll-find-if-you-keep-reading" id="toc-what-youll-find-if-you-keep-reading" class="nav-link" data-scroll-target="#what-youll-find-if-you-keep-reading">What you’ll find if you keep reading</a></li>
  </ul></li>
  <li><a href="#numerical-framework" id="toc-numerical-framework" class="nav-link" data-scroll-target="#numerical-framework">Numerical framework</a>
  <ul class="collapse">
  <li><a href="#entangling-blocks" id="toc-entangling-blocks" class="nav-link" data-scroll-target="#entangling-blocks">Entangling blocks</a></li>
  <li><a href="#optimization-with-jax" id="toc-optimization-with-jax" class="nav-link" data-scroll-target="#optimization-with-jax">Optimization with <code>JAX</code></a>
  <ul class="collapse">
  <li><a href="#a-word-about-jax" id="toc-a-word-about-jax" class="nav-link" data-scroll-target="#a-word-about-jax">A word about <code>JAX</code></a></li>
  <li><a href="#gradient-descent" id="toc-gradient-descent" class="nav-link" data-scroll-target="#gradient-descent">Gradient descent</a></li>
  </ul></li>
  <li><a href="#quantum-circuits-with-numpy" id="toc-quantum-circuits-with-numpy" class="nav-link" data-scroll-target="#quantum-circuits-with-numpy">Quantum circuits with <code>numpy</code></a></li>
  <li><a href="#layers" id="toc-layers" class="nav-link" data-scroll-target="#layers">Layers</a></li>
  <li><a href="#packing-everything-together-ansatz-circuits" id="toc-packing-everything-together-ansatz-circuits" class="nav-link" data-scroll-target="#packing-everything-together-ansatz-circuits">Packing everything together: ansatz circuits</a></li>
  </ul></li>
  <li><a href="#experiments" id="toc-experiments" class="nav-link" data-scroll-target="#experiments">Experiments</a>
  <ul class="collapse">
  <li><a href="#learning-2-qubit-random-unitary" id="toc-learning-2-qubit-random-unitary" class="nav-link" data-scroll-target="#learning-2-qubit-random-unitary">Learning 2-qubit random unitary</a></li>
  <li><a href="#learning-3-qubit-random-unitary" id="toc-learning-3-qubit-random-unitary" class="nav-link" data-scroll-target="#learning-3-qubit-random-unitary">Learning 3-qubit random unitary</a></li>
  <li><a href="#learning-6-qubit-random-unitary" id="toc-learning-6-qubit-random-unitary" class="nav-link" data-scroll-target="#learning-6-qubit-random-unitary">Learning 6-qubit random unitary</a></li>
  <li><a href="#restricted-topology" id="toc-restricted-topology" class="nav-link" data-scroll-target="#restricted-topology">Restricted topology</a></li>
  </ul></li>
  <li><a href="#final-remarks" id="toc-final-remarks" class="nav-link" data-scroll-target="#final-remarks">Final remarks</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div class="cell" data-tags="[]" data-execution_count="46">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># If you are running this notebook in Colab, you might need to restart</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"># the environment after the installations.</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> jnp</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> random, value_and_grad, jit, vmap, grad, lax</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> unitary_group</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> optax</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span>pip install optax</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> optax</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> qiskit</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">ImportError</span>:</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span>pip install qiskit</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span>pip install pylatexenc <span class="co"># required for circuit drawing.</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> qiskit</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit <span class="im">import</span> QuantumCircuit, transpile</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.quantum_info <span class="im">import</span> Operator, Statevector</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.circuit <span class="im">import</span> Parameter</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.transpiler.passes.synthesis <span class="im">import</span> UnitarySynthesis</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.transpiler <span class="im">import</span> PassManager</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.converters <span class="im">import</span> circuit_to_gate</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><a target="_blank" href="https://colab.research.google.com/github/idnm/blog/blob/master/posts/machine_learning_compilation_experiments/2021-12-13-Machine%20learning%20compilation%20of%20quantum%20circuits%20--%20experiments.ipynb"> <img src="https://colab.research.google.com/assets/colab-badge.svg" align="right" alt="Open In Colab"> </a></p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>Ever since I read the paper by L.Madden and A.Simonetto (<a href="http://arxiv.org/abs/2106.05649">original preprint</a>, <a href="https://idnm.github.io/blog/machine%20learning/compilation/qiskit/paper%20review/2021/07/22/Machine-learning-compilation-of-quantum-circuits.html">my review</a>) I knew I want to do this kind of experiments myself. At first I hoped that there is a well-developed software framework where I can easily build quantum circuits and then optimize them efficiently. However, <a href="https://quantumcomputing.stackexchange.com/questions/20718/software-tools-to-train-quantum-circuits-with-parameters">I was not able to find a good fit for my problem</a>. For example, to the best of my knowledge <code>qiskit</code> currently only provides acess to zero-order optimization routines. I later found <a href="https://quimb.readthedocs.io/en/latest/index.html">quimb</a> which <a href="https://quimb.readthedocs.io/en/latest/examples/ex_tn_train_circuit.html">might do what I want</a>, but in the end I’m glad I worked things out from scratch. Eventually I went for <code>numpy</code>+<code>JAX</code> combination which while being quite low-level was not a big problem to get working and shows a decent speed. I owe a ton to <a href="https://github.com/LuchnikovI">Ilia Luchnikov</a> for introducing me to the framework and helping throught.</p>
<p>In this post I will give a walk thorough this implementation and show experiments with compilation of random unitaries. However, in my opinion truly interesting stuff is concerned with the compilation of special gates, say multi-controlled Toffolis on restricted connectivity. I intend to look at this kind problems in detail in a future blog post. You may wish to take a look at <a href="http://arxiv.org/abs/2109.13223">this preprint</a> for advances in that direction.</p>
<blockquote class="blockquote">
<p><em>NOTE</em>: While I was working on my experiments another <a href="http://arxiv.org/abs/2109.06770">preprint appeared</a>, by P.Rakyta and Z.Zimborás, which is very similar to the work of M&amp;S in terms of numerical results. Despite the striking similarities these works are independent. As a bonus R&amp;Z also provide a numerical package <a href="https://zenodo.org/record/4508680#.YVw-uYBBxNi">SQUANDER</a> that allows to play with their framework for compilation of unitaries. You might want to check that out if you are interested in doing some experiments yourself.</p>
</blockquote>
</section>
<section id="the-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-problem">The problem</h2>
<p>OK, so first a brief recap of what is the compilation problem. Given a quantum circuit we need to find an equivalent one, which satisfies certain requirements. A typical restrictions are to use only some specific two-qubits gates and to be compatible with limited connectivity. I gave a more detailed intro <a href="https://idnm.github.io/blog/machine%20learning/compilation/qiskit/paper%20review/2021/07/22/Machine-learning-compilation-of-quantum-circuits.html">here</a>. Here is a nearly-trivial example: a simple <span class="math inline">\(CNOT\)</span> gate</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>qc <span class="op">=</span> QuantumCircuit(<span class="dv">2</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>qc.cx(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>qc.draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="2">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-3-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>can be decomposed in terms of the entangling <span class="math inline">\(cz\)</span> gate and single-qubit gates <span class="math inline">\(rx, ry, rz\)</span> as follows</p>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>qc_compiled <span class="op">=</span> transpile(qc, basis_gates<span class="op">=</span>[<span class="st">'cz'</span>, <span class="st">'rx'</span>, <span class="st">'ry'</span>, <span class="st">'rz'</span>], optimization_level<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>qc_compiled.draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="3">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Now, for generic <span class="math inline">\(n\)</span>-qubit unitaries one needs exponentially many entangling gates for the compilation. More precisely, there is a <a href="https://dl.acm.org/doi/10.5555/968879.969163">theoretical lower bound</a> <span class="math inline">\(\#CNOTs\ge \frac14 \left(4^n-3n-1\right)\)</span> on the amount of <span class="math inline">\(CNOT\)</span>s required for compilation of any <span class="math inline">\(n-\)</span>qubit unitary outside a measure zero set. Crucially, this measure zero set might in fact be of principal interest to quantum computing as it includes many operators featuring in most algorithms (such as multi-controlled gates). In this post I will only adress compilation of random unitaries and discuss compilation of special cases in a future post. For later reference here is the function computing the theoretical lower bound.</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> TLB(n):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">int</span>((<span class="dv">4</span><span class="op">**</span>n<span class="op">-</span><span class="dv">3</span><span class="op">*</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span><span class="dv">4</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'TLB for </span><span class="sc">{}</span><span class="st">-qubit unitary is </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(n, TLB(n)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>TLB for 1-qubit unitary is 1
TLB for 2-qubit unitary is 3
TLB for 3-qubit unitary is 14
TLB for 4-qubit unitary is 61
TLB for 5-qubit unitary is 253
TLB for 6-qubit unitary is 1020</code></pre>
</div>
</div>
<p>Now, there is an algorithm called <a href="https://arxiv.org/abs/quant-ph/0406176">quantum Shannon decomposition</a> to decompose an arbitary <span class="math inline">\(n\)</span>-qubit unitary into a sequence of <span class="math inline">\(CNOT\)</span>s and single-qubit rotations which requires roughly twice as many <span class="math inline">\(CNOT\)</span>s as the theoretical lower bound implies. In complexity-theoretic terms this is definitely good enoough, the overhead is just a small constant factor. However, for NISQ devices doubling the amount of gates is not a trivial matter. Is it possible to do better?</p>
</section>
<section id="qubit-example" class="level2">
<h2 class="anchored" data-anchor-id="qubit-example">3-qubit example</h2>
<p>As papers <a href="http://arxiv.org/abs/2106.05649">M&amp;S</a> and <a href="http://arxiv.org/abs/2109.06770">R&amp;Z</a> show, one can do better and eliminate the 2x overhead, at least numerically. Namely, it seems that precisely at the theoretical lower bound the exact or nearly-exact compilation of any unitary is possible. Here is a real-life example. Consider the following 3-qubit circuit with <span class="math inline">\(TLB(3)=14\)</span> <span class="math inline">\(CNOT\)</span> gates</p>
<p><img src="3qubitsequ.png" alt="Drawing" style="width: 800px;"></p>
<p>The claim is that with the appropriate choice of angles in rotation gates it can morhp into <em>any</em> 3-qubit unitary (and in fact at least this many <span class="math inline">\(CNOT\)</span>s are needed for almost all 3-qubit unitaries). To find the corresponding angles it is sufficient to run a numerical optimization minimizing the fidelity between this circuit’s unitary and the target unitary. To me this is rather imressive, but raises several questions. Why choose <span class="math inline">\(CNOT\)</span> gates of all entangling gates? Why place them in that exact order as shown at the figure? It appears to be an empirical fact that precise location of entangling gates as well as their choice (<span class="math inline">\(CNOT\)</span>, <span class="math inline">\(cz\)</span>, etc) makes little difference. Moreover, even restricted connectivity does not seem to force an overhead for compilation. It is my main goal to back up these claims with numerical experiments in an interactive way. In particular, I will illustrate the following points.</p>
<ol type="1">
<li>Exactly at the theoretical lower bound a nearly-exact compilation seems to always be possible (at least for up to 6 qubits). This is a 2x improvement over the best theoretical decomposition.</li>
<li>Both <span class="math inline">\(cz\)</span> and <span class="math inline">\(CNOT\)</span> gates perform equally well. It is tempting to guess that any entangling gate will perform similarly.</li>
<li>The maximum fidelity is a monotonic function of the number of entangling gates. This implies that simply counting 2-qubit gates gives a good measure of circuits expressivity.</li>
<li>The most remarkable for me is the fact that even a restricted topology seems to cause no overhead on compilation cost. I will show that even on a chain topology the same amount of <span class="math inline">\(CNOT\)</span>s is sufficient to reach good fidelity.</li>
</ol>
</section>
<section id="what-youll-find-if-you-keep-reading" class="level2">
<h2 class="anchored" data-anchor-id="what-youll-find-if-you-keep-reading">What you’ll find if you keep reading</h2>
<p>The rest of this post is divided into two parts. In the first I write some <code>numpy</code>/<code>JAX</code>/<code>qiskit</code> code that allows to construct and efficiently optimize parametrized circuits. I try to give some explanations of the underlying numerical framework, but please take into account that my own understanding is rather limited. Still, the resulting performance seems to be good enough to reproduce results of the existing preprints. I advise to skip this part if you are only interested in the results.</p>
<p>In the second part of the post I will do a number of experiments compiling random unitaries with varying numbers of qubits, different types of entangling gates, restricted connectivity and try to draw some general lessons from them. I tried to make this part independent of the first, although I didn’t stop all the implementation details from sinking trough.</p>
<blockquote class="blockquote">
<p><em>NOTE</em>: This blog post is also a fully functional jupyter notebook. You can open it in Colab or download locally and perform more experiments yourself!</p>
</blockquote>
<p><img src="pisa.svg" alt="Drawing" style="width: 400px;"></p>
</section>
</section>
<section id="numerical-framework" class="level1">
<h1>Numerical framework</h1>
<section id="entangling-blocks" class="level2">
<h2 class="anchored" data-anchor-id="entangling-blocks">Entangling blocks</h2>
<p>First let us define the basic 1- and 2-qubit gates in matrix form. For now you can safely ignore the use <code>jnp</code> arrays instead of <code>np</code> arrays.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Matrix represntations of CNOT, CZ and single-qubit rotations</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Controlled-NOT (or controlled-X gate)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>cx_mat <span class="op">=</span> jnp.array([[<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]])</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Controlled-Z gate</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>cz_mat <span class="op">=</span> jnp.array([[<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Pauli matrices</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>x_mat <span class="op">=</span> jnp.array([[<span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>                   [<span class="dv">1</span>, <span class="dv">0</span>]])</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>y_mat <span class="op">=</span> jnp.array([[<span class="dv">0</span>, <span class="op">-</span><span class="ot">1j</span>],</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                   [<span class="ot">1j</span>, <span class="dv">0</span>]], dtype<span class="op">=</span>jnp.complex64)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>z_mat <span class="op">=</span> jnp.array([[<span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                   [<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]])</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Rotation gates</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rx_mat(a):</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.cos(a<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>jnp.identity(<span class="dv">2</span>)<span class="op">-</span><span class="ot">1j</span><span class="op">*</span>x_mat<span class="op">*</span>jnp.sin(a<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ry_mat(a):</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.cos(a<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>jnp.identity(<span class="dv">2</span>)<span class="op">-</span><span class="ot">1j</span><span class="op">*</span>y_mat<span class="op">*</span>jnp.sin(a<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rz_mat(a):</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.cos(a<span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>jnp.identity(<span class="dv">2</span>)<span class="op">-</span><span class="ot">1j</span><span class="op">*</span>z_mat<span class="op">*</span>jnp.sin(a<span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>WARNING:absl:No GPU/TPU found, falling back to CPU. (Set TF_CPP_MIN_LOG_LEVEL=0 and rerun for more info.)</code></pre>
</div>
</div>
<p>The circuits that we are going to train will be built out of two types of 2-qubit blocks, the controlled-Z and the controlled-NOT. Here are the definitions:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> block():</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Two-qubit entangling block.</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Methods:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">        circuit: gives equivalent `qiskit` circuit.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">        unitary: gives `jax.numpy` unitary matrix of the circuit.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, gate_name, angles):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gate_name <span class="op">=</span> gate_name</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.angles <span class="op">=</span> angles</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> circuit(<span class="va">self</span>):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Quantum circuit in `qiskit` corresponding to our block."""</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        qc <span class="op">=</span> QuantumCircuit(<span class="dv">2</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.gate_name <span class="op">==</span> <span class="st">'cx'</span>:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            qc.cx(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.gate_name <span class="op">==</span> <span class="st">'cz'</span>:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            qc.cz(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Gate '</span><span class="sc">{}</span><span class="st">' not yet supported'"</span>.<span class="bu">format</span>(<span class="va">self</span>.gate_name))</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        angles <span class="op">=</span> np.array(<span class="va">self</span>.angles) <span class="co"># convert from JAX array to numpy array if applicable.</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        qc.ry(angles[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        qc.rx(angles[<span class="dv">1</span>], <span class="dv">0</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        qc.ry(angles[<span class="dv">2</span>], <span class="dv">1</span>)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        qc.rx(angles[<span class="dv">3</span>], <span class="dv">1</span>)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> qc</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> unitary(<span class="va">self</span>):</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""JAX-compatible unitary corresponding to our block."""</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.gate_name <span class="op">==</span> <span class="st">'cx'</span>:</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>            entangling_matrix <span class="op">=</span> cx_mat</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.gate_name <span class="op">==</span> <span class="st">'cz'</span>:</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>            entangling_matrix <span class="op">=</span> cz_mat</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Gate '</span><span class="sc">{}</span><span class="st">' not yet supported'"</span>.<span class="bu">format</span>(<span class="va">self</span>.gate_name))</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>        x_rotations <span class="op">=</span> jnp.kron(rx_mat(<span class="va">self</span>.angles[<span class="dv">1</span>]), rx_mat(<span class="va">self</span>.angles[<span class="dv">3</span>]))</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>        y_rotations <span class="op">=</span> jnp.kron(ry_mat(<span class="va">self</span>.angles[<span class="dv">0</span>]), ry_mat(<span class="va">self</span>.angles[<span class="dv">2</span>]))</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x_rotations <span class="op">@</span> y_rotations <span class="op">@</span> entangling_matrix</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is how they look: <code>cz</code> block</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>a0, a1, a2, a3 <span class="op">=</span> [Parameter(a) <span class="cf">for</span> a <span class="kw">in</span> [<span class="st">'a0'</span>, <span class="st">'a1'</span>, <span class="st">'a2'</span>, <span class="st">'a3'</span>]]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>block(<span class="st">'cz'</span>, [a0, a1, a2, a3]).circuit().draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-8-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>and <code>cx</code> block</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>block(<span class="st">'cx'</span>, [a0, a1, a2, a3]).circuit().draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-9-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Our <code>block</code> class can return a <code>qiskit</code> circuit and the corresponding unitary matrix. Of course we could have extracted the unitary from the circuit itself via <code>qiskit</code> API, but this would make the matrix representation incompatible with <code>JAX</code> which will be our workhorse for optimization. To the best of my knowledge currently it is only possible to use zero-order methods directly from <code>qiskit</code> which is a serious limitation. So at this point we needed a bit of wheel reinvention. Let’s check that our implementation is consistent with <code>qiskit</code>:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># That's how you use random numbers with JAX. Don't worry if this is not familiar, not essential for our purposes.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> random.uniform(random.PRNGKey(<span class="dv">0</span>), shape<span class="op">=</span>(<span class="dv">4</span>,), minval<span class="op">=</span><span class="dv">0</span>, maxval<span class="op">=</span><span class="dv">2</span><span class="op">*</span>jnp.pi)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> gate <span class="kw">in</span> [<span class="st">'cx'</span>, <span class="st">'cz'</span>]:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> block(gate, angles)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    qc <span class="op">=</span> b.circuit()</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    qs_unitary <span class="op">=</span> Operator(qc.reverse_bits()).data <span class="co"># Yes, we need to reverse bits in qiskit to match our conventions.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    our_unitary <span class="op">=</span> b.unitary()</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'qiskit unitary is the same as our unitary for block with gate </span><span class="sc">{}</span><span class="st">: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(gate, jnp.allclose(qs_unitary, our_unitary)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>qiskit unitary is the same as our unitary for block with gate cx: True
qiskit unitary is the same as our unitary for block with gate cz: True</code></pre>
</div>
</div>
<p>To match matrix representations of quantum circuits might be a headache as I discussed in <a href="https://idnm.github.io/blog/qiskit/tensor%20networks/quantum%20concepts/2021/08/18/Matrix-representation-of-quantum-circuits.html">another post</a>, so this was a necessary check to do.</p>
<p>Our two building blocks (<code>cz</code> and <code>cx</code>) only differ by the type of the two-qubit gate. The circuits that we are going to build seem to do equally well for any choice of two-qubit gate. I will mostly use <code>cz</code> gate because it is symmetric under the swap of qubits, but I will also occasionally bring up the <code>cx</code> gate to illustrate that it has the same performance. Angles <span class="math inline">\(a_0\)</span>-<span class="math inline">\(a_3\)</span> are going to be optimized.</p>
</section>
<section id="optimization-with-jax" class="level2">
<h2 class="anchored" data-anchor-id="optimization-with-jax">Optimization with <code>JAX</code></h2>
<section id="a-word-about-jax" class="level3">
<h3 class="anchored" data-anchor-id="a-word-about-jax">A word about <code>JAX</code></h3>
<p>What is <code>JAX</code>? Well, I personally think of it as <code>numpy</code> on steroids. You can check out <a href="https://jax.readthedocs.io/en/latest/notebooks/quickstart.html">the official documentation</a> or numerous nice overwievs on the web. For our purposes two key features of <code>JAX</code> are 1. Autograd.<br>
2. JIT or just-in-time compilation.</p>
<p>Autograd allows to define functions the same way you do in <code>numpy</code> and have analytic derivatives available with no extra coding on your side. At the moment <code>grad</code> function can only be applied to real scalars. For example, let us define the absolute value of the trace of <code>cx</code> block as function of rotations gate angles</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> block_tr_abs(angles):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> block(<span class="st">'cx'</span>, angles)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    tr <span class="op">=</span> jnp.trace(b.unitary())</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.<span class="bu">abs</span>(tr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Since everything so far has been defined using <code>jax.numpy</code> we have immediate access to the gradient of this function</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>grad(block_tr_abs)([<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">2.</span>,<span class="fl">3.</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<pre><code>[DeviceArray(0.03655498, dtype=float32),
 DeviceArray(-0.25903472, dtype=float32),
 DeviceArray(-0.7384602, dtype=float32),
 DeviceArray(-7.450581e-09, dtype=float32)]</code></pre>
</div>
</div>
<p>Autograd feature of <code>JAX</code> allows us to just define the loss function associated with our circuit in plain <code>numpy</code> terms and use advanced first-order optimizers such as Adam out of the box.</p>
<p>The next crucial ingredient is <code>jit</code>-compilation. When used with a bit of care, it allows to speed up evaluation of similar expression by orders of magnitude. For example let us compare runtimes of the <code>jit</code>ted and un<code>jit</code>ted versions of our trace function. Let’s first define a sample of random angles</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>test_angles <span class="op">=</span> random.uniform(random.PRNGKey(<span class="dv">0</span>), shape<span class="op">=</span>(<span class="dv">1000</span>, <span class="dv">4</span>), minval<span class="op">=</span><span class="dv">0</span>, maxval<span class="op">=</span><span class="dv">2</span><span class="op">*</span>jnp.pi)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>and now time evaluation of un<code>jit</code>ted trace function</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> angles <span class="kw">in</span> test_angles:</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    block_tr_abs(angles)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 12.3 s, sys: 1.02 s, total: 13.3 s
Wall time: 11.4 s</code></pre>
</div>
</div>
<p>Now awe to the power of <code>jit</code>!</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>jit_block_tr_abs <span class="op">=</span> jit(block_tr_abs)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> angles <span class="kw">in</span> test_angles:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    jit_block_tr_abs(angles)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 156 ms, sys: 7.94 ms, total: 164 ms
Wall time: 145 ms</code></pre>
</div>
</div>
<p>What happened here is that during the first call to the <code>jit</code>ted function it’s efficient <code>XLA</code> version was compiled and then used to evaluate all subsequent calls.</p>
</section>
<section id="gradient-descent" class="level3">
<h3 class="anchored" data-anchor-id="gradient-descent">Gradient descent</h3>
<p>We will use the following measure of discrepancy between two unitaries <span class="math inline">\(disc(U, V) = 1-\frac1{N}\operatorname{Tr}\left( U^\dagger V\right)\)</span> where <span class="math inline">\(U,V\)</span> are <span class="math inline">\(N\times N\)</span> matrices. It is normalized so that <span class="math inline">\(disc(U,U)=0\)</span> and <span class="math inline">\(disc(U,V)=0\)</span> when <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are orthogonal. Note that this measure is insensitive to global phases.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> disc(U, U_target):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> U_target.shape[<span class="dv">0</span>]</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">-</span>jnp.<span class="bu">abs</span>((U.conj() <span class="op">*</span> U_target).<span class="bu">sum</span>())<span class="op">/</span>n</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is the optimization routine that we are going to use. It is pretty straightforward and I will not give much explanations, but illustrate with an example.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="at">@partial</span>(jit, static_argnums<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">1</span>, )) <span class="co"># &lt;--- Here is where the magic happens! </span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>                                       <span class="co"># Remove this line and everything will run 1000 times slower:)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unitary_update(loss_and_grad, opt, opt_state, angles):</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Single update step."""</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    loss, grads <span class="op">=</span> loss_and_grad(angles)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    updates, opt_state <span class="op">=</span> opt.update(grads, opt_state)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    angles <span class="op">=</span> optax.apply_updates(angles, updates)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> angles, opt_state, loss</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unitary_learn(U_func, U_target, n_angles, </span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>                  init_angles<span class="op">=</span><span class="va">None</span>, key<span class="op">=</span>random.PRNGKey(<span class="dv">0</span>),</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>                  learning_rate<span class="op">=</span><span class="fl">0.01</span>, num_iterations<span class="op">=</span><span class="dv">5000</span>, </span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>                  target_disc<span class="op">=</span><span class="fl">1e-10</span>):</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Use Adam optimizer to minimize discrepancy between pamaterzied unitary and targe unitary.</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a><span class="co">        U_func: function of angles returning univary matrix.</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co">        U_target: unitary matrix to approximate.</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="co">        n_angles: total number of angles (parameters) in U_func.</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a><span class="co">        init_angles: intial angles for gradient descent. If not provided chosen at random.</span></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="co">        key: random seed to use for inizialization of initial angles.</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a><span class="co">        learning_rate: learning rate in Adam optimizer.</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span class="co">        num_iterations: maximum number of iterations.</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a><span class="co">        target_disc: stop optimization if discrepancy drops below target_disc.</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns: tuple (angles_history, loss_history) where</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span class="co">        angles_history: list of angles (parameters) at each iteration step.</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a><span class="co">        loss_history: values of loss_function at each iteration step.</span></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If initial angles are not provided generate them at random.</span></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> init_angles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>        key <span class="op">=</span> random.PRNGKey(<span class="dv">0</span>)</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        angles <span class="op">=</span> random.uniform(key, shape<span class="op">=</span>(n_angles,), minval<span class="op">=</span><span class="dv">0</span>, maxval<span class="op">=</span><span class="dv">2</span><span class="op">*</span>jnp.pi)</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>        angles <span class="op">=</span> init_angles</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Loss function to minimize is dicrepancy defined above.</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    loss_func <span class="op">=</span> <span class="kw">lambda</span> angles: disc(U_func(angles), U_target)</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>    loss_and_grad <span class="op">=</span> value_and_grad(loss_func)</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optimizer is taken from the `optax` library and its use is self-explanotory.</span></span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    opt <span class="op">=</span> optax.adam(learning_rate)</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>    opt_state <span class="op">=</span> opt.init(angles)</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optimization cycle</span></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>    angles_history<span class="op">=</span>[]</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>    loss_history<span class="op">=</span>[]</span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_iterations):</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>        angles, opt_state, loss <span class="op">=</span> unitary_update(loss_and_grad, opt, opt_state, angles)</span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a>        angles_history.append(angles)</span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a>        loss_history.append(loss)</span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> loss <span class="op">&lt;</span> target_disc:</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> angles_history, loss_history</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>OK, now a very simple example. Say we want to find a <span class="math inline">\(ZXZ\)</span> decomposition of <span class="math inline">\(Y\)</span>-gate. Define:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zxz_ansatz(angles):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rz_mat(angles[<span class="dv">0</span>]) <span class="op">@</span> rx_mat(angles[<span class="dv">1</span>]) <span class="op">@</span> rz_mat(angles[<span class="dv">2</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Learning is now very simple: we give <code>unitary_learn</code> the ansatz unitary as function of angles, the target unitary and also explicitly the number of parameters to be trained:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>angles_history, loss_history <span class="op">=</span> unitary_learn(zxz_ansatz, y_mat, <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can visualize the learning progress as follows:</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">'log'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-20-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The learned angles in <span class="math inline">\(ZXZ\)</span> decomposition are</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>angles_history[<span class="op">-</span><span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>DeviceArray([6.59216  , 3.1411407, 3.4505684], dtype=float32)</code></pre>
</div>
</div>
<p>It is not difficult to check directly that the result is equal to the <span class="math inline">\(Y\)</span> matrix up to a global phase with reasonable accuracy, indeed</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>jnp.around(<span class="ot">1j</span><span class="op">*</span>zxz_ansatz(angles_history[<span class="op">-</span><span class="dv">1</span>]), <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>DeviceArray([[0.+0.j, 0.-1.j],
             [0.+1.j, 0.+0.j]], dtype=complex64)</code></pre>
</div>
</div>
</section>
</section>
<section id="quantum-circuits-with-numpy" class="level2">
<h2 class="anchored" data-anchor-id="quantum-circuits-with-numpy">Quantum circuits with <code>numpy</code></h2>
<p>Now it’s time to build full quantum circuits. We will think of a quantum circuit on <span class="math inline">\(n\)</span> qubits as a tensor with <span class="math inline">\(2*n\)</span> legs. First <span class="math inline">\(n\)</span> legs correspond to <em>output</em> and last to <span class="math inline">\(n\)</span> <em>input</em>. This is illustrated at the picture.</p>
<p><img src="tensor.svg" alt="Drawing" style="width: 540px;"></p>
<p>It is natural for input legs to be on the left because in matrix notation a unitary <span class="math inline">\(U\)</span> acts on a state <span class="math inline">\(\psi\)</span> by left multiplication <span class="math inline">\(U\psi\)</span>. On the other hand note that quantum circuits are usually drawn left-to-right and to compare the two descriptions a left-right reflection must be made.</p>
<p>Suppose now that given an <span class="math inline">\(n-\)</span>qubit circuit <span class="math inline">\(U\)</span> we want to append an additional <span class="math inline">\(m-\)</span>qubit gate <span class="math inline">\(V\)</span> at the end. Here is a concrete example (a picture is worth a thousand words!)</p>
<p><img src="tensor_contraction.svg" alt="Drawing" style="width: 540px;"> Several things to keep in mind:</p>
<ol type="1">
<li>To append gate <span class="math inline">\(V\)</span> at the end in quantum circuit notation, we need to draw it on the left here.</li>
<li>Tensor legs are joined by <code>numpy</code>’s <code>tensordot</code> operation. Which axes to contract is clear from the picture – we need to join axes 2, 3 of <span class="math inline">\(V\)</span> to 1, 3 of <span class="math inline">\(U\)</span>.</li>
<li>In the resulting tensor the output legs are not in the correct order. Instead of being numbered from top to bottom after <code>tensordot</code> first several axes are those of <span class="math inline">\(V\)</span> and the remaining are uncontracted output axes of <span class="math inline">\(U\)</span> (take a look at the leftmost column of numbers). This needs to be corrected by explicit transposition of output axes.</li>
<li>The final caveat is that if some of the legs connecting gate to the circuit are twisted the output legs needs to be transposed accordingly. Here is an example</li>
</ol>
<p><img src="tensor_contraction_twisted.svg" alt="Drawing" style="width: 640px;"></p>
<p>Here is the code that implements this program.</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gate_transposition(placement):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Determine transposition associated with initial placement of gate."""</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    position_index <span class="op">=</span> [(placement[i], i) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(placement))]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    position_index.sort()</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    transposition <span class="op">=</span> [i <span class="cf">for</span> _,i <span class="kw">in</span> position_index]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> transposition</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> transposition(n_qubits, placement):</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return a transposition that relabels tensor axes correctly.</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Example (from the figure above): n=6, placement=[1, 3] gives [2, 0, 3, 1, 4, 5].</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Twiseted: n=6, placement=[3, 1] gives [2, 1, 3, 0, 4, 5]."""</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    gate_width <span class="op">=</span> <span class="bu">len</span>(placement)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(gate_width, n_qubits))</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> position, insertion <span class="kw">in</span> <span class="bu">zip</span>(<span class="bu">sorted</span>(placement), gate_transposition(placement)):</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        t.insert(position, insertion)</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> apply_gate_to_tensor(gate, tensor, placement):</span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Append `gate` to `tensor` along legs specified by `placement`. Transpose the output axes properly."""</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a>    gate_width <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(gate.shape)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>    tensor_width <span class="op">=</span> <span class="bu">int</span>(<span class="bu">len</span>(tensor.shape)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># contraction axes for `tensor` are input axes (=last half of all axes)</span></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a>    gate_contraction_axes <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(gate_width, <span class="dv">2</span><span class="op">*</span>gate_width)) </span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>    contraction <span class="op">=</span> jnp.tensordot(gate, tensor, axes<span class="op">=</span>[gate_contraction_axes, placement])</span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># input(=last half) indices are intact</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    t <span class="op">=</span> transposition(tensor_width, placement) <span class="op">+</span> <span class="bu">list</span>(<span class="bu">range</span>(tensor_width, <span class="dv">2</span><span class="op">*</span>tensor_width)) </span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> jnp.transpose(contraction, axes<span class="op">=</span>t)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, using this tensor language we will construct unitary matrices corresponding to our ansatz circuits. To specify the ansatz we must supply the number of qubits in the circuit, type of entangling blocks to use and arrangement of these blocks.</p>
<p>The simplest way to specify arrangement would be to just give a list like <code>[[0,1], [1, 3], [2, 1]]</code> etc of pairs of qubits to put entangling blocks on to. However for performance reasons I need to make it more complicated. To construct a matrix for our quantum circuit we basically need to loop over all entangling gates and append them one by one. When using <code>JAX</code> plain python loops are simply unrolled and then compiled. For large loops this leads to very large compilation times. If there is no structure in how we place our gates in the circuit this is probably the best one can do. However, we can be more efficient than that if there is a structure. Take a look at this picture</p>
<div class="cell" data-execution_count="23">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>qc <span class="op">=</span> QuantumCircuit(<span class="dv">4</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">11</span>):</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    qc.cx(i,i<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> (i<span class="op">+</span><span class="dv">1</span>) <span class="op">%</span> <span class="dv">3</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">%</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        qc.barrier()</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>qc.draw()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">                     ░                 ░                 ░           
q_0: ──■─────────────░───■─────────────░───■─────────────░───■───────
     ┌─┴─┐           ░ ┌─┴─┐           ░ ┌─┴─┐           ░ ┌─┴─┐     
q_1: ┤ X ├──■────────░─┤ X ├──■────────░─┤ X ├──■────────░─┤ X ├──■──
     └───┘┌─┴─┐      ░ └───┘┌─┴─┐      ░ └───┘┌─┴─┐      ░ └───┘┌─┴─┐
q_2: ─────┤ X ├──■───░──────┤ X ├──■───░──────┤ X ├──■───░──────┤ X ├
          └───┘┌─┴─┐ ░      └───┘┌─┴─┐ ░      └───┘┌─┴─┐ ░      └───┘
q_3: ──────────┤ X ├─░───────────┤ X ├─░───────────┤ X ├─░───────────
               └───┘ ░           └───┘ ░           └───┘ ░           </pre>
</div>
</div>
<p>Here <span class="math inline">\(CNOT\)</span>s are just placeholders for any entangling block of our interest. There is a regular pattern. Most of the circuit consists of identical layers up to a couple of final gates. Construction and optimization of such circuits with <code>JAX</code> can be made way more efficient by using <code>lax.fori_loop</code> (<a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.fori_loop.html">see here for docs</a>) or a similar construct. This allows to exploit the regularity and reduce the compilation time dramatically.</p>
<p>The price to pay is a bit of a hassle in separating all gates into regular ones and the remainder. My core function <code>build_unitary</code> accepts the regular layers as an argument <code>layer_placements=[layer, number_of_repetitions]</code> and the remainder gates are described by <code>free_placements</code>. Also, we need some way to access all parameters (angles) in our circuit. I chose the simplest approach here, to supply angles as a 1d array, but internally they play a bit different roles so there is also a function <code>split_angles</code> to separate a 1d array of all angles into several logical blocks.</p>
<p>OK, so here is the code. Examples are found in the end of this section.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_angles(angles, num_qubits, layer_len, num_layers, free_placements_len):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Splits 1d array of all angles in a circuit into four groups.</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">        angles: all angles in a circuit as 1d array.</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">        num_qubits: number of qubits in a circuit.</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">        layer_len: length (depth) of a single layer in a circuit.</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">        num_layers: number of repeated layers.</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">        free_placements_len: number of entanglig blocks not in layers.</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:  a tuple (surface_angles, layers_angles, free_block_angles) where</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co">        surface_angles: angles in initial single-qubit blocks.</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="co">        block_angles: angles of all entangling blocks.</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="co">        layers_angles: angles for entangling blocks that are parts of complete layers.</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="co">        free_block_angles: angles of remaining entangling blocks.</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span> </span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>    surface_angles <span class="op">=</span> angles[:<span class="dv">3</span><span class="op">*</span>num_qubits].reshape(num_qubits, <span class="dv">3</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>    block_angles <span class="op">=</span> angles[<span class="dv">3</span><span class="op">*</span>num_qubits:].reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">4</span>)</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>    layers_angles <span class="op">=</span> block_angles[:layer_len<span class="op">*</span>num_layers].reshape(num_layers, layer_len, <span class="dv">4</span>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>    free_block_angles <span class="op">=</span> block_angles[layer_len<span class="op">*</span>num_layers:]</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> surface_angles, block_angles, layers_angles, free_block_angles</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> build_unitary(num_qubits, block_type, angles, layer_placements<span class="op">=</span>((), <span class="dv">0</span>), free_placements<span class="op">=</span>()):</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="co">    Builds `JAX`-compatible unitary matrix of a quantum circuit.</span></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="co">   </span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Arguments specify structure of the circuit and values of parameters.</span></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="co">        num_qubits: number of qubits.</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a><span class="co">        block_type: type of entangling block to use. Currently only 'cx' and 'cz' are supported.</span></span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="co">        angles: 1d array of all angle parameters in the circuit.</span></span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a><span class="co">        layer_placements: a tuple (single_layer, n) where `single_layer` specifies </span></span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a><span class="co">            positions of several entangling blocks and `n` how many time to repeat each layer.</span></span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a><span class="co">        free_placements: Positions of entangling blocks that do no belong to layers.</span></span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="co">        A `jax.numpy` unitary matrix of the quantum circuit.</span></span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a>    layer, num_layers <span class="op">=</span> layer_placements</span>
<span id="cb32-44"><a href="#cb32-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-45"><a href="#cb32-45" aria-hidden="true" tabindex="-1"></a>    layer_depth <span class="op">=</span> <span class="bu">len</span>(layer)    </span>
<span id="cb32-46"><a href="#cb32-46" aria-hidden="true" tabindex="-1"></a>    num_blocks <span class="op">=</span> <span class="bu">len</span>(layer)<span class="op">*</span>num_layers<span class="op">+</span><span class="bu">len</span>(free_placements) <span class="co"># Count all entangling blocks.</span></span>
<span id="cb32-47"><a href="#cb32-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-48"><a href="#cb32-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Divides 1d array of all angles into three logically distinct groups.</span></span>
<span id="cb32-49"><a href="#cb32-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-50"><a href="#cb32-50" aria-hidden="true" tabindex="-1"></a>    surface_angles, _, layers_angles, free_block_angles <span class="op">=</span> split_angles(angles, num_qubits, </span>
<span id="cb32-51"><a href="#cb32-51" aria-hidden="true" tabindex="-1"></a>                                                                    <span class="bu">len</span>(layer), num_layers, <span class="bu">len</span>(free_placements))</span>
<span id="cb32-52"><a href="#cb32-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-53"><a href="#cb32-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initizlizes identity matrix of the proper size.</span></span>
<span id="cb32-54"><a href="#cb32-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-55"><a href="#cb32-55" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> jnp.identity(<span class="dv">2</span><span class="op">**</span>num_qubits).reshape([<span class="dv">2</span>]<span class="op">*</span>num_qubits<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb32-56"><a href="#cb32-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-57"><a href="#cb32-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Unitary matrix is built in three steps. </span></span>
<span id="cb32-58"><a href="#cb32-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First, 3 single-qubit gates are applied to each qubit.</span></span>
<span id="cb32-59"><a href="#cb32-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Second, all entangling blocks that are parts of layers are applied.</span></span>
<span id="cb32-60"><a href="#cb32-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Finally, remainder blocks that a not parts any layer are applied.</span></span>
<span id="cb32-61"><a href="#cb32-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-62"><a href="#cb32-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial round of single-qubit gates</span></span>
<span id="cb32-63"><a href="#cb32-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-64"><a href="#cb32-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, a <span class="kw">in</span> <span class="bu">enumerate</span>(surface_angles):</span>
<span id="cb32-65"><a href="#cb32-65" aria-hidden="true" tabindex="-1"></a>        gate <span class="op">=</span> rz_mat(a[<span class="dv">2</span>]) <span class="op">@</span> rx_mat(a[<span class="dv">1</span>]) <span class="op">@</span> rz_mat(a[<span class="dv">0</span>])</span>
<span id="cb32-66"><a href="#cb32-66" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> apply_gate_to_tensor(gate, u, [i])</span>
<span id="cb32-67"><a href="#cb32-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-68"><a href="#cb32-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sequence of layers wrapped in `fori_loop`.</span></span>
<span id="cb32-69"><a href="#cb32-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Using `fori_loop` instead of plain `for` loop reduces the compilation time significantly.</span></span>
<span id="cb32-70"><a href="#cb32-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># To use `fori_loop` it is convenient to define a separate function that applies a whole layer of gates.</span></span>
<span id="cb32-71"><a href="#cb32-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-72"><a href="#cb32-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-73"><a href="#cb32-73" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> apply_layer(i, u, layer, layers_angles):</span>
<span id="cb32-74"><a href="#cb32-74" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Apply several gates to a given quantum circuit.</span></span>
<span id="cb32-75"><a href="#cb32-75" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb32-76"><a href="#cb32-76" aria-hidden="true" tabindex="-1"></a><span class="co">        Supplying the totality of `layers_angles` makes </span></span>
<span id="cb32-77"><a href="#cb32-77" aria-hidden="true" tabindex="-1"></a><span class="co">        the function compatible with `fori_loop`.</span></span>
<span id="cb32-78"><a href="#cb32-78" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb32-79"><a href="#cb32-79" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb32-80"><a href="#cb32-80" aria-hidden="true" tabindex="-1"></a><span class="co">            i: index of the layer.</span></span>
<span id="cb32-81"><a href="#cb32-81" aria-hidden="true" tabindex="-1"></a><span class="co">            u: matrix to apply gates to.</span></span>
<span id="cb32-82"><a href="#cb32-82" aria-hidden="true" tabindex="-1"></a><span class="co">            layer: positions of all gates to be applied.</span></span>
<span id="cb32-83"><a href="#cb32-83" aria-hidden="true" tabindex="-1"></a><span class="co">            layers_angles: angles of all layers.        </span></span>
<span id="cb32-84"><a href="#cb32-84" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb32-85"><a href="#cb32-85" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb32-86"><a href="#cb32-86" aria-hidden="true" tabindex="-1"></a>        layer_angles <span class="op">=</span> layers_angles[i]</span>
<span id="cb32-87"><a href="#cb32-87" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-88"><a href="#cb32-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> block_angles, position <span class="kw">in</span> <span class="bu">zip</span>(layer_angles, layer):</span>
<span id="cb32-89"><a href="#cb32-89" aria-hidden="true" tabindex="-1"></a>            gate <span class="op">=</span> block(block_type, block_angles).unitary().reshape(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>) </span>
<span id="cb32-90"><a href="#cb32-90" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> apply_gate_to_tensor(gate, u, position)</span>
<span id="cb32-91"><a href="#cb32-91" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb32-92"><a href="#cb32-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> u</span>
<span id="cb32-93"><a href="#cb32-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-94"><a href="#cb32-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_layers<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb32-95"><a href="#cb32-95" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> lax.fori_loop(<span class="dv">0</span>, num_layers, <span class="kw">lambda</span> i, u: apply_layer(i, u, layer, layers_angles), u)</span>
<span id="cb32-96"><a href="#cb32-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-97"><a href="#cb32-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adds the remainding (free) entangling blocks.</span></span>
<span id="cb32-98"><a href="#cb32-98" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-99"><a href="#cb32-99" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> angles, position <span class="kw">in</span> <span class="bu">zip</span>(free_block_angles, free_placements):</span>
<span id="cb32-100"><a href="#cb32-100" aria-hidden="true" tabindex="-1"></a>        gate <span class="op">=</span> block(block_type, angles).unitary().reshape(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb32-101"><a href="#cb32-101" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> apply_gate_to_tensor(gate, u, position)</span>
<span id="cb32-102"><a href="#cb32-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-103"><a href="#cb32-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> u.reshape(<span class="dv">2</span><span class="op">**</span>num_qubits, <span class="dv">2</span><span class="op">**</span>num_qubits)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="layers" class="level2">
<h2 class="anchored" data-anchor-id="layers">Layers</h2>
<p>Here are a couple of simple functions to help define gate arrangements. The basic layer is <code>sequ_layer</code> which consists of entangling gates applied to each possible pair of two qubit gates enumerated by pairs <span class="math inline">\((i,j)\)</span> with <span class="math inline">\(i&lt;j\)</span>.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sequ_layer(num_qubits):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [[i,j] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_qubits) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, num_qubits)]</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fill_layers(layer, depth):</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    num_complete_layers <span class="op">=</span> depth <span class="op">//</span> <span class="bu">len</span>(layer)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    complete_layers <span class="op">=</span> [layer, num_complete_layers]</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    incomplete_layer <span class="op">=</span> layer[:depth <span class="op">%</span> <span class="bu">len</span>(layer)]</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> complete_layers, incomplete_layer</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Function <code>fill_layers</code> allows to specify how much entangling gates we want in total and splits them into complete layers (to be used as <code>layer_placements</code>) and possible remainder gates (that become <code>free_placements</code>). For example, a <code>sequ_layer</code> on three qubits consists of three gates at positions</p>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>sequ_layer(<span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>[[0, 1], [0, 2], [1, 2]]</code></pre>
</div>
</div>
<p>If we want to have the sequ pattern and 10 entangling gates in total we can put three complete layers and a final single gate. <code>fill_layers</code> does just that</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>layer_placements, free_placements <span class="op">=</span> fill_layers(sequ_layer(<span class="dv">3</span>), <span class="dv">10</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(layer_placements)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(free_placements)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[[[0, 1], [0, 2], [1, 2]], 3]
[[0, 1]]</code></pre>
</div>
</div>
</section>
<section id="packing-everything-together-ansatz-circuits" class="level2">
<h2 class="anchored" data-anchor-id="packing-everything-together-ansatz-circuits">Packing everything together: ansatz circuits</h2>
<p>Now that we have defined our building blocks and convenience functions to assemble them it is time to pack everything together and reap the harvest.</p>
<p>I will define <code>ansatz</code> class that assembles our building blocks according to a predefined pattern. It’s <code>circuit</code> method gives a <code>qiskit</code> circuit which can be used for visualization and cross-checks. It’s <code>unitary</code> attribute returns fully <code>jax</code>-compatible matrix representation of the same circuit. Finally, its <code>learn</code> method uses our optimization routine to approximate a target unitary. First the code, then an example.</p>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Ansatz():</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Parametric quantum circuit.</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Ansatz/parametric circuit is defined by tupes of entangling blocks and their arrangement.</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Concrete values of parameters are not considered part of the ansatz. Class provides access</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="co">    to both `qiskit` version of the circuit and `jax.numpy` unitary matrix.</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Attributes:</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="co">        num_qubits: number of qubits</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="co">        block_type: type of entangling blocks</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co">        num_angles: total number of angles (parameters) in the circuit.</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="co">        unitary: `jax.numpy` unitary matrix of the circuit as function of angles.</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Methods:</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co">        circuit: `qiskit` version of the circuit.</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="co">        learn: numerical approximation of the target unitary.</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_qubits, block_type, layer_placements<span class="op">=</span>[[], <span class="dv">0</span>], free_placements<span class="op">=</span>[]):</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_qubits <span class="op">=</span> num_qubits</span>
<span id="cb38-22"><a href="#cb38-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.block_type <span class="op">=</span> block_type</span>
<span id="cb38-23"><a href="#cb38-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-24"><a href="#cb38-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.layer, <span class="va">self</span>.num_layers <span class="op">=</span> layer_placements</span>
<span id="cb38-25"><a href="#cb38-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.free_placements <span class="op">=</span> free_placements</span>
<span id="cb38-26"><a href="#cb38-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.all_placements <span class="op">=</span> <span class="va">self</span>.layer<span class="op">*</span><span class="va">self</span>.num_layers<span class="op">+</span>free_placements</span>
<span id="cb38-27"><a href="#cb38-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-28"><a href="#cb38-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_angles <span class="op">=</span> <span class="dv">3</span><span class="op">*</span>num_qubits<span class="op">+</span><span class="dv">4</span><span class="op">*</span><span class="bu">len</span>(<span class="va">self</span>.all_placements)</span>
<span id="cb38-29"><a href="#cb38-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-30"><a href="#cb38-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.unitary <span class="op">=</span> <span class="kw">lambda</span> angles: build_unitary(<span class="va">self</span>.num_qubits, <span class="va">self</span>.block_type, angles, </span>
<span id="cb38-31"><a href="#cb38-31" aria-hidden="true" tabindex="-1"></a>                                                     layer_placements<span class="op">=</span>[<span class="va">self</span>.layer, <span class="va">self</span>.num_layers], </span>
<span id="cb38-32"><a href="#cb38-32" aria-hidden="true" tabindex="-1"></a>                                                     free_placements<span class="op">=</span><span class="va">self</span>.free_placements)</span>
<span id="cb38-33"><a href="#cb38-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> circuit(<span class="va">self</span>, angles<span class="op">=</span><span class="va">None</span>): </span>
<span id="cb38-34"><a href="#cb38-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""qiskit version circuit. If angles not specified a parametric circuit is constructed."""</span></span>
<span id="cb38-35"><a href="#cb38-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-36"><a href="#cb38-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> angles <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb38-37"><a href="#cb38-37" aria-hidden="true" tabindex="-1"></a>            angles <span class="op">=</span> np.array([Parameter(<span class="st">'a</span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(i)) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_angles)])</span>
<span id="cb38-38"><a href="#cb38-38" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb38-39"><a href="#cb38-39" aria-hidden="true" tabindex="-1"></a>        surface_angles, block_angles, _, _ <span class="op">=</span> split_angles(angles, <span class="va">self</span>.num_qubits, </span>
<span id="cb38-40"><a href="#cb38-40" aria-hidden="true" tabindex="-1"></a>                                                          <span class="bu">len</span>(<span class="va">self</span>.layer), <span class="va">self</span>.num_layers, </span>
<span id="cb38-41"><a href="#cb38-41" aria-hidden="true" tabindex="-1"></a>                                                          <span class="bu">len</span>(<span class="va">self</span>.free_placements))        </span>
<span id="cb38-42"><a href="#cb38-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-43"><a href="#cb38-43" aria-hidden="true" tabindex="-1"></a>        qc <span class="op">=</span> QuantumCircuit(<span class="va">self</span>.num_qubits)</span>
<span id="cb38-44"><a href="#cb38-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-45"><a href="#cb38-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Initial round of single-qubit gates.</span></span>
<span id="cb38-46"><a href="#cb38-46" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-47"><a href="#cb38-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n, a <span class="kw">in</span> <span class="bu">enumerate</span>(surface_angles):</span>
<span id="cb38-48"><a href="#cb38-48" aria-hidden="true" tabindex="-1"></a>            qc.rz(a[<span class="dv">0</span>], n)</span>
<span id="cb38-49"><a href="#cb38-49" aria-hidden="true" tabindex="-1"></a>            qc.rx(a[<span class="dv">1</span>], n)</span>
<span id="cb38-50"><a href="#cb38-50" aria-hidden="true" tabindex="-1"></a>            qc.rz(a[<span class="dv">2</span>], n)</span>
<span id="cb38-51"><a href="#cb38-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-52"><a href="#cb38-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Entangling gates accoring to placements</span></span>
<span id="cb38-53"><a href="#cb38-53" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-54"><a href="#cb38-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a, p <span class="kw">in</span> <span class="bu">zip</span>(block_angles, <span class="va">self</span>.all_placements):</span>
<span id="cb38-55"><a href="#cb38-55" aria-hidden="true" tabindex="-1"></a>            qc_block <span class="op">=</span> block(<span class="va">self</span>.block_type, a).circuit() </span>
<span id="cb38-56"><a href="#cb38-56" aria-hidden="true" tabindex="-1"></a>            qc <span class="op">=</span> qc.compose(qc_block, p)</span>
<span id="cb38-57"><a href="#cb38-57" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb38-58"><a href="#cb38-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> qc</span>
<span id="cb38-59"><a href="#cb38-59" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-60"><a href="#cb38-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> learn(<span class="va">self</span>, u_target, <span class="op">**</span>kwargs): </span>
<span id="cb38-61"><a href="#cb38-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Use numerical optimization to approximate u_target."""</span></span>
<span id="cb38-62"><a href="#cb38-62" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb38-63"><a href="#cb38-63" aria-hidden="true" tabindex="-1"></a>        u_func <span class="op">=</span> <span class="va">self</span>.unitary</span>
<span id="cb38-64"><a href="#cb38-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> unitary_learn(u_func, u_target, <span class="va">self</span>.num_angles, <span class="op">**</span>kwargs)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is an example that should illustrate how all this can be used.</p>
<div class="cell" data-tags="[]" data-execution_count="29">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>n_qubits <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>block_type <span class="op">=</span> <span class="st">'cx'</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co"># For technical reasons all entangling gates are divided into 'layers' and 'free' gates. </span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>single_layer <span class="op">=</span> [[<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">2</span>, <span class="dv">1</span>]] <span class="co"># We make single layer consisting of 'cx' block on qubits [0,1]</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>                                <span class="co"># followed by reversed 'cx' block on qubits [1,2].</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>layers <span class="op">=</span> [single_layer, <span class="dv">3</span>] <span class="co"># The layer is repeated 3 times.</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>free_placements <span class="op">=</span> [[<span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">2</span>, <span class="dv">1</span>]] <span class="co"># Apeend remaining `free placements` a.</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>anz <span class="op">=</span> Ansatz(n_qubits, block_type, layer_placements<span class="op">=</span>layers, free_placements<span class="op">=</span>free_placements)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is what resulting circuit looks like.</p>
<div class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>anz.circuit().draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-31-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Just to make sure let us check that the unitary matrix of this circuit extracted from qiskit agrees with our own implementation for a random set of angles.</p>
<div class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> random.uniform(random.PRNGKey(<span class="dv">0</span>), shape<span class="op">=</span>(anz.num_angles,), minval<span class="op">=</span><span class="dv">0</span>,maxval<span class="op">=</span><span class="dv">2</span><span class="op">*</span>jnp.pi)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>qs_u <span class="op">=</span> Operator(anz.circuit(angles).reverse_bits()).data <span class="co"># qiskit matrix representation</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>our_u <span class="op">=</span> anz.unitary(angles) <span class="co"># our matrix representation</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(jnp.allclose(qs_u, our_u, rtol<span class="op">=</span><span class="fl">1e-6</span>, atol<span class="op">=</span><span class="fl">1e-7</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True</code></pre>
</div>
</div>
</section>
</section>
<section id="experiments" class="level1">
<h1>Experiments</h1>
<p>Now that the hard work is behind we can sit back and reap the benefits. I will go through a series of examples. Primary goal is to back up the claims from the introduction about reaching the theoretical lower bound, agile performance on restricted topology etc. But I will also try to make clear how my code can be used if you wish to do a little experimenting with it yourself.</p>
<section id="learning-2-qubit-random-unitary" class="level2">
<h2 class="anchored" data-anchor-id="learning-2-qubit-random-unitary">Learning 2-qubit random unitary</h2>
<p>Let’s start by learning a random 2-qubits unitary. First, define one.</p>
<div class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>u_target <span class="op">=</span> unitary_group.rvs(<span class="dv">4</span>, random_state<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is the parametrized circuit we are going to use. <code>cz</code> means that the entangling gate is controlled-Z while <code>free_placements</code> are just positions where to put these entangling gates. There isn’t much choice for 2 qubits as you could guess. I will explain why I call these <code>free_placements</code> a bit later.</p>
<div class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>anz <span class="op">=</span> Ansatz(<span class="dv">2</span>, <span class="st">'cz'</span>, free_placements<span class="op">=</span>[[<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>,<span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>]])</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>anz.circuit().draw(output<span class="op">=</span><span class="st">'mpl'</span>) <span class="co"># anz.circuit() is a fully-functional `qiskit` version of our ansatz.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-34-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The learning process is easy as pie:</p>
<div class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>angles_history, loss_history <span class="op">=</span> anz.learn(u_target)</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">'log'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 2.45 s, sys: 21.4 ms, total: 2.48 s
Wall time: 2.43 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-35-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>The graph shows that we achieve great fidelity in under 500 iterations.</p>
<p>Don’t believe me? Is there a way to tell if this plot indeed reflects a successful compilation without looking under the hood? OK OK, since you’re asking, I will double-check using pure <code>qiskit</code>:</p>
<div class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>angles <span class="op">=</span> angles_history[<span class="op">-</span><span class="dv">1</span>] <span class="co"># Last(=best) angles in the optimization process.</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>qc <span class="op">=</span> anz.circuit(angles) <span class="co"># genuine qiskit circuit. </span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>u_qs <span class="op">=</span> Operator(qc.reverse_bits()).data <span class="co"># qiskit API to extract the unitary matrix.</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>disc(u_qs, u_target) <span class="co"># OK, I guess here you have believe I've implemented the cost function properly.</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>                     <span class="co"># If you want to compare the matrices component-wise, fine with me.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<pre><code>DeviceArray(2.3841858e-07, dtype=float32)</code></pre>
</div>
</div>
<p>Similar checks can be done in more complicated scenarios below.</p>
<p>You can move forward to other examples or try some experiments here. Some ideas: 1. Changing gate type from <code>cz</code> to <code>cx</code> (should not affect the result). 1. Decreasing the number of layers (fidelity won’t be nearly as good). 1. Increasing the number of layers (same fidelity with less iterations).</p>
</section>
<section id="learning-3-qubit-random-unitary" class="level2">
<h2 class="anchored" data-anchor-id="learning-3-qubit-random-unitary">Learning 3-qubit random unitary</h2>
<p>I advertised in the introduction that with just 14 entangling gates any 3-qubit unitary can be nearly perfectly approximated. Let me back up this claim. Here is how we can construct the corresponding ansatz.</p>
<div class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>num_qubits <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>block_type <span class="op">=</span> <span class="st">'cz'</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>depth <span class="op">=</span> <span class="dv">14</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>layer_placemets, free_placements <span class="op">=</span> fill_layers(sequ_layer(num_qubits), depth)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>anz <span class="op">=</span> Ansatz(num_qubits, block_type, layer_placements<span class="op">=</span>layer_placements, free_placements<span class="op">=</span>free_placements)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>anz.circuit().draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="36">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-37-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The way gate placements are passes to <code>Ansatz</code> here require a bit of unpacking. This is an implementation detail I didn’t take enough care to hide. For technical reasons I explained in the numerical section optimization is much faster when gates are arranged in a regular pattern. The pattern we use here is called <code>sequ_layer</code> and for three qubits it is simply</p>
<div class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>sequ_layer(num_qubits)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>[[0, 1], [0, 2], [1, 2]]</code></pre>
</div>
</div>
<p>i.e.&nbsp;it just lists all possible pairs of three qubits. However, since 14 % 3 = 2 the two last gates do not fit into the regular pattern and require a bit of a special treatment. This is what the function <code>fill_layers</code> does for us. Indeed</p>
<div class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>layer_placements, free_placements <span class="op">=</span> fill_layers(sequ_layer(num_qubits), depth)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'basic layer is repeated four times:'</span>, layer_placements)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'remaining blocks reside at positions:'</span>, free_placements)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>basic layer is repeated four times: [[[0, 1], [0, 2], [1, 2]], 4]
remaining blocks reside at positions: [[0, 1], [0, 2]]</code></pre>
</div>
</div>
<p>I hope that did explain the way that gate positions are passed to the <code>Ansatz</code>. Instead of <code>sequ_layer</code> you can pass any arrangment of gates to be periodically repeated. We will do just that when considering a restricted topology.</p>
<p>Now let’s run the optimization.</p>
<div class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>u_target <span class="op">=</span> unitary_group.rvs(<span class="dv">2</span><span class="op">**</span>num_qubits, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>angles_history, loss_history <span class="op">=</span> anz.learn(u_target)</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history)</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">'log'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 9.75 s, sys: 177 ms, total: 9.92 s
Wall time: 9.18 s</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-40-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>OK, I hope this does convince you that our ansatz was indeed good enough! Another interesting thing to do is to make a sweep to see how the fidelity increases (error drops) with the number of layers.</p>
<div class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>best_loss <span class="op">=</span> [[], []]</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> depth <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">15</span>): <span class="co"># TLB(3)=14</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    layer_placemets, free_placements <span class="op">=</span> fill_layers(sequ_layer(n_qubits), depth)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, block_type <span class="kw">in</span> <span class="bu">enumerate</span>([<span class="st">'cx'</span>, <span class="st">'cz'</span>]):</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>        anz <span class="op">=</span> Ansatz(num_qubits, block_type, layer_placements<span class="op">=</span>layer_placemets, free_placements<span class="op">=</span>free_placements)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>        angles, loss_history <span class="op">=</span> anz.learn(u_target, target_disc<span class="op">=</span><span class="fl">10e-4</span>)</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        best_loss[i].append(<span class="bu">min</span>(loss_history))</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>plt.plot(best_loss[<span class="dv">0</span>], label<span class="op">=</span><span class="st">'cx loss'</span>)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>plt.plot(best_loss[<span class="dv">1</span>], label<span class="op">=</span><span class="st">'cz loss'</span>)</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'error'</span>)</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'number of entangling gates'</span>)</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>plt.legend()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 3min 49s, sys: 6.68 s, total: 3min 55s
Wall time: 3min 35s</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="40">
<pre><code>&lt;matplotlib.legend.Legend at 0x7f39d2950a60&gt;</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-41-output-3.png" class="img-fluid"></p>
</div>
</div>
<p>One lesson here is that both types of two-qubits gate perform similarly well at all depths. This is not surprising for because <code>cx</code> and <code>cz</code> gates can be related by single-qubit Hadamard transformations. It would be interesting to see if other two-qubit gates perform differently.</p>
<p>Another important observation is that the best fidelity is a monotonic function of the the amount of two-qubit gates. There is some work on variational algorithms testing various metrics that would adequately reflect expressivity of the ansatz. I think that plain number of <span class="math inline">\(CNOT\)</span> gates should in fact be a fantastic and simple metric for this.</p>
</section>
<section id="learning-6-qubit-random-unitary" class="level2">
<h2 class="anchored" data-anchor-id="learning-6-qubit-random-unitary">Learning 6-qubit random unitary</h2>
<p>I do know that 3 is followed by 4, but shall we perhaps get more ambitious? Let’s try to compile a 6-qubit random unitary (you can try to go higher if your machine allows):</p>
<div class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>num_qubits <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>depth <span class="op">=</span> TLB(num_qubits) <span class="co"># 1020 for 6 qubits</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>layer_placements, free_placements <span class="op">=</span> fill_layers(sequ_layer(num_qubits), depth)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>u_target <span class="op">=</span> unitary_group.rvs(<span class="dv">2</span><span class="op">**</span>num_qubits, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>anz <span class="op">=</span> Ansatz(num_qubits, <span class="st">'cz'</span>, layer_placements<span class="op">=</span>layer_placements, free_placements<span class="op">=</span>free_placements)</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>angles_history, loss_history <span class="op">=</span> anz.learn(u_target, num_iterations<span class="op">=</span><span class="dv">5000</span>)</span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'number of qubits: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(num_qubits))</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'number of iterations'</span>)</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'error'</span>)</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history)</span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">'log'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 5min 33s, sys: 1min 1s, total: 6min 34s
Wall time: 6min 28s</code></pre>
</div>
<div class="cell-output cell-output-display">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-42-output-2.png" class="img-fluid"></p>
</div>
</div>
<p>Note that depth of the theoretical lower bound for 6 qubits is <span class="math inline">\(TLB(6)=1020\)</span> which implies that there are <span class="math inline">\(\approx 4000\)</span> parameters in our ansatz. On my modest laptop the training completes in about 10 minutes. Of course I would not claim this to be the cutting edge, but our <code>JAX</code> setup seems to be competitive at the scale (3-6 qubits) addressed in the literature so far.</p>
</section>
<section id="restricted-topology" class="level2">
<h2 class="anchored" data-anchor-id="restricted-topology">Restricted topology</h2>
<p>One of the most remarkable features of this approach is that topology restrictions do not seem to bring any overhead to compilation of random unitaries. To make the point and illustrate this claim I will consider the least connected topology I can think of, the chain topology. The corresponding layer consists of all pairs of adjacent qubits.</p>
<div class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> chain_layer(num_qubits):</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> [(i,i<span class="op">+</span><span class="dv">1</span>) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_qubits<span class="op">-</span><span class="dv">1</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here is a 6-qubit illustration.</p>
<div class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>Ansatz(<span class="dv">6</span>, <span class="st">'cx'</span>, layer_placements<span class="op">=</span>[chain_layer(<span class="dv">6</span>), <span class="dv">1</span>]).circuit().draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-44-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Here I drew a single layer consisting of 5 blocks. To reach the theoretical lower bound requires to stack together 1020/5=204 layers. Let’s do that and see how the learning goes.</p>
<div class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span>time</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>num_qubits <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>depth <span class="op">=</span> TLB(num_qubits)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>layer_placements, free_placements <span class="op">=</span> fill_layers(chain_layer(num_qubits), depth)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>u_target <span class="op">=</span> unitary_group.rvs(<span class="dv">2</span><span class="op">**</span>num_qubits, random_state<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>anz <span class="op">=</span> Ansatz(num_qubits, <span class="st">'cx'</span>, layer_placements<span class="op">=</span>layer_placements, free_placements<span class="op">=</span>free_placements)</span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>angles_history_chain, loss_history_chain <span class="op">=</span> anz.learn(u_target)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>CPU times: user 5min 9s, sys: 1min 3s, total: 6min 13s
Wall time: 6min</code></pre>
</div>
</div>
<p>Let’s compare the results with the previously considered fully connected topology.</p>
<div class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'number of qubits: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(num_qubits))</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'number of iterations'</span>)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'error'</span>)</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history, label<span class="op">=</span><span class="st">'fully connected'</span>)</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history_chain, label<span class="op">=</span><span class="st">'chain'</span>)</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>plt.yscale(<span class="st">'log'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="2021-12-13-Machine learning compilation of quantum circuits -- experiments_files/figure-html/cell-46-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>As you can see, the chain topology performs only slightly worse than the fully connected topology which seems truly remarkable.</p>
</section>
</section>
<section id="final-remarks" class="level1">
<h1>Final remarks</h1>
<p>The main goal was to illustrate that numerical compilation of small-scale random unitaries can be very efficient in terms of gate count, and seems to reach the theoretical lower bound in all cases considered, regardless of topological restrictions.</p>
<p>It is interesting to note that a variety of optimization procedures are used in the literature. In <a href="http://arxiv.org/abs/2106.05649">M&amp;S</a> a simple version of the gradient descent is used, in <a href="http://arxiv.org/abs/2109.06770">R&amp;Z</a> an interesting procedure of one-qubit gate decoupling is used (I must admit I do not understand exactly what it does), and in <a href="http://arxiv.org/abs/2109.13223">KTS preprint</a> a funny optimization one-angle-at a time is used (because as a function of each angle the circuit is a simple triginometric function, it is trivial to optimize one parameter at a time). Here we used a slightly more advanced version of the gradient descent, the Adam algorithm. All approaches seem to work well on random unitaries.</p>
<p>My preliminary investigations show that for special gates things get much more complicated than for generic random unitaries. But this is where the most intersting stuff is found, e.g.&nbsp;compilation of multi-component Toffoli gates on restricted connectivity. I hope to address these cases in a future blog post!</p>



</section>

<div class="quarto-listing quarto-listing-container-default" id="listing-listing">
<div class="list quarto-listing-default">

</div>
<div class="listing-no-matching d-none">
No matching items
</div>
</div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="idnm/blog" data-repo-id="R_kgDOJWB1vg" data-category="General" data-category-id="DIC_kwDOJWB1vs4CVvR7" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>