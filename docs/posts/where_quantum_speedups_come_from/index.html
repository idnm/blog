<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-07-10">
<meta name="description" content="What makes quantum computers powerful? Explained as simple as possible, but no simpler.">

<title>Notes on Quantum Computing - Where do quantum speedups come from?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../kika.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-listing .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-date','listing-title','listing-description','listing-categories','listing-image',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-file-modified-sort'] }],
      
      searchColumns: [],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-listing'] = new List('listing-listing', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1154MLY31V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1154MLY31V', { 'anonymize_ip': true});
</script>
<script>
window.MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Notes on Quantum Computing</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Where do quantum speedups come from?</h1>
                  <div>
        <div class="description">
          What makes quantum computers powerful? Explained as simple as possible, but no simpler.
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">quantum concepts</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 10, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#intro" id="toc-intro" class="nav-link active" data-scroll-target="#intro">Intro</a></li>
  <li><a href="#qubits-superposition-and-amplitudes" id="toc-qubits-superposition-and-amplitudes" class="nav-link" data-scroll-target="#qubits-superposition-and-amplitudes">Qubits, superposition, and amplitudes</a></li>
  <li><a href="#probabilistic-interpretation-of-superposition" id="toc-probabilistic-interpretation-of-superposition" class="nav-link" data-scroll-target="#probabilistic-interpretation-of-superposition">Probabilistic interpretation of superposition</a></li>
  <li><a href="#quantum-mechanics-is-a-theory-of-amplitudes" id="toc-quantum-mechanics-is-a-theory-of-amplitudes" class="nav-link" data-scroll-target="#quantum-mechanics-is-a-theory-of-amplitudes">Quantum mechanics is a theory of amplitudes</a>
  <ul class="collapse">
  <li><a href="#quantum-processes" id="toc-quantum-processes" class="nav-link" data-scroll-target="#quantum-processes">Quantum processes</a></li>
  <li><a href="#bit-flipping" id="toc-bit-flipping" class="nav-link" data-scroll-target="#bit-flipping">Bit flipping</a></li>
  <li><a href="#qubit-flipping" id="toc-qubit-flipping" class="nav-link" data-scroll-target="#qubit-flipping">Qubit flipping</a></li>
  <li><a href="#amplitudes-can-cancel-probabilities-cant" id="toc-amplitudes-can-cancel-probabilities-cant" class="nav-link" data-scroll-target="#amplitudes-can-cancel-probabilities-cant">Amplitudes can cancel, probabilities can’t</a></li>
  </ul></li>
  <li><a href="#quantum-states-of-multiple-qubits" id="toc-quantum-states-of-multiple-qubits" class="nav-link" data-scroll-target="#quantum-states-of-multiple-qubits">Quantum states of multiple qubits</a></li>
  <li><a href="#why-quantum-interference-defies-classical-simulation" id="toc-why-quantum-interference-defies-classical-simulation" class="nav-link" data-scroll-target="#why-quantum-interference-defies-classical-simulation">Why quantum interference defies classical simulation</a></li>
  <li><a href="#why-quantum-interference-leads-to-quantum-speed-ups" id="toc-why-quantum-interference-leads-to-quantum-speed-ups" class="nav-link" data-scroll-target="#why-quantum-interference-leads-to-quantum-speed-ups">Why quantum interference leads to quantum speed ups</a>
  <ul class="collapse">
  <li><a href="#deutschs-algorithm" id="toc-deutschs-algorithm" class="nav-link" data-scroll-target="#deutschs-algorithm">Deutsch’s algorithm</a></li>
  <li><a href="#grovers-algorithm" id="toc-grovers-algorithm" class="nav-link" data-scroll-target="#grovers-algorithm">Grover’s algorithm</a>
  <ul class="collapse">
  <li><a href="#quantum-search" id="toc-quantum-search" class="nav-link" data-scroll-target="#quantum-search">Quantum search</a></li>
  <li><a href="#grovers-oracle" id="toc-grovers-oracle" class="nav-link" data-scroll-target="#grovers-oracle">Grover’s oracle</a></li>
  <li><a href="#the-initial-state" id="toc-the-initial-state" class="nav-link" data-scroll-target="#the-initial-state">The initial state</a></li>
  <li><a href="#reflections" id="toc-reflections" class="nav-link" data-scroll-target="#reflections">Reflections</a></li>
  <li><a href="#two-dimensional-subspace" id="toc-two-dimensional-subspace" class="nav-link" data-scroll-target="#two-dimensional-subspace">Two-dimensional subspace</a></li>
  <li><a href="#grovers-algorithm-is-a-sequence-of-small-rotations" id="toc-grovers-algorithm-is-a-sequence-of-small-rotations" class="nav-link" data-scroll-target="#grovers-algorithm-is-a-sequence-of-small-rotations">Grover’s algorithm is a sequence of small rotations</a></li>
  <li><a href="#infinitesimal-quantum-speedup" id="toc-infinitesimal-quantum-speedup" class="nav-link" data-scroll-target="#infinitesimal-quantum-speedup">Infinitesimal quantum speedup</a></li>
  <li><a href="#quantum-interference" id="toc-quantum-interference" class="nav-link" data-scroll-target="#quantum-interference">Quantum interference</a></li>
  <li><a href="#beyond-oracles" id="toc-beyond-oracles" class="nav-link" data-scroll-target="#beyond-oracles">Beyond oracles</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#faq" id="toc-faq" class="nav-link" data-scroll-target="#faq">FAQ</a>
  <ul class="collapse">
  <li><a href="#oh-my-who-reads-posts-this-long-gimme-tldr." id="toc-oh-my-who-reads-posts-this-long-gimme-tldr." class="nav-link" data-scroll-target="#oh-my-who-reads-posts-this-long-gimme-tldr.">Oh my, who reads posts this long? Gimme TLDR.</a></li>
  <li><a href="#why-didnt-you-say-anything-about-electrons-superconductors-schrödinger-cats" id="toc-why-didnt-you-say-anything-about-electrons-superconductors-schrödinger-cats" class="nav-link" data-scroll-target="#why-didnt-you-say-anything-about-electrons-superconductors-schrödinger-cats">Why didn’t you say anything about electrons, superconductors, Schrödinger cats?</a></li>
  <li><a href="#i-thought-quantum-computers-are-powered-by-quantum-entanglement" id="toc-i-thought-quantum-computers-are-powered-by-quantum-entanglement" class="nav-link" data-scroll-target="#i-thought-quantum-computers-are-powered-by-quantum-entanglement">I thought quantum computers are powered by quantum entanglement!</a></li>
  <li><a href="#what-about-classical-interference" id="toc-what-about-classical-interference" class="nav-link" data-scroll-target="#what-about-classical-interference">What about classical interference?</a></li>
  <li><a href="#what-use-is-grovers-algorithm" id="toc-what-use-is-grovers-algorithm" class="nav-link" data-scroll-target="#what-use-is-grovers-algorithm">What use is Grover’s algorithm?</a></li>
  <li><a href="#what-about-errors" id="toc-what-about-errors" class="nav-link" data-scroll-target="#what-about-errors">What about errors?</a></li>
  <li><a href="#alright-what-other-quantum-algorithms-are-there" id="toc-alright-what-other-quantum-algorithms-are-there" class="nav-link" data-scroll-target="#alright-what-other-quantum-algorithms-are-there">Alright, what other quantum algorithms are there?</a></li>
  <li><a href="#what-is-the-killer-app" id="toc-what-is-the-killer-app" class="nav-link" data-scroll-target="#what-is-the-killer-app">What is the killer app?</a></li>
  <li><a href="#how-long-before-quantum-chatbots" id="toc-how-long-before-quantum-chatbots" class="nav-link" data-scroll-target="#how-long-before-quantum-chatbots">How long before quantum chatbots?</a></li>
  <li><a href="#what-else-can-i-read" id="toc-what-else-can-i-read" class="nav-link" data-scroll-target="#what-else-can-i-read">What else can I read?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="intro" class="level1">
<h1>Intro</h1>
<p>In this post, I try to explain why quantum computers can be more powerful than classical. And I aim for an explanation “as simple as possible, but no simpler”. This is not exactly trivial, because there is no precise classical analogy to quantum behavior. It was a paradigm shift, after all. Likely, all popular explanations you saw, like “it’s exponentially large state space”, or “it’s entanglement”, are incomplete at best. However, the math underlying basic quantum phenomena is pretty simple. Following it, you can see precisely how quantum things work, and perhaps build some intuition.</p>
<p>I will only rely on a minimal background in linear algebra, basic probability, and elementary complexity theory (understanding why an algorithm taking <span class="math inline">\(\sqrt{N}\)</span> steps is better than the one taking <span class="math inline">\(N\)</span> steps suffices). There are two points to address.</p>
<ol type="1">
<li>Why a classical computer can not efficiently reproduce, i.e.&nbsp;<em>simulate</em>, an arbitrary quantum computation?</li>
<li>Why some of these quantum computations solve useful problems?</li>
</ol>
<p>To make quantum computing of general interest, you really need both.</p>
<p>Quantum computing is not really about physics. Rather, quantum mechanics can be understood as a variation of the probability theory. Standard probability theory deals with probabilities, which are positive numbers. Quantum mechanics instead deals with probability <em>amplitudes</em>. Probability amplitudes, when squared, give proper probabilities. But amplitudes can be both positive or negative (or even complex numbers, but this won’t be important for us). In a sense, all quantum weirdness can be attributed to this seemingly superficial distinction.</p>
<p>There is more than one way to highlight the difference between classical and quantum. Comparing them head-to-head is tricky, simply because we usually use very different language to describe the two. Here, I will focus on comparing quantum mechanics with classical probability theory. Some features often perceived as unique to quantum systems, such as the exponentially large state space, are in fact present in probabilistic systems as well. Overall, it makes for a fairer apples-to-apples kind of comparison.</p>
</section>
<section id="qubits-superposition-and-amplitudes" class="level1">
<h1>Qubits, superposition, and amplitudes</h1>
<p>Classical computers manipulate classical <em>bits</em>, i.e.&nbsp;systems that can be in one of two states, <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span>. Quantum computers manipulate quantum bits, or <em>qubits</em>. Similarly to a classical bit, a qubit can be in two states, denoted by <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>. However, a qubit can also be in a state described by an (almost) arbitrary linear combination</p>
<p><span class="math display">\[\begin{align}
|\psi\rangle = a_0 |0\rangle+a_1 |1\rangle  \ .
\end{align}\]</span></p>
<p>The states <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> should be thought of as two orthogonal two-dimensional vectors. For instance, in explicit computations one often sets <span class="math inline">\(|0\rangle = \begin{pmatrix} 1 \\ 0\end{pmatrix}, |1\rangle = \begin{pmatrix} 0 \\ 1\end{pmatrix}\)</span>. Also, notation <span class="math inline">\(|\cdot\rangle\)</span> is nothing more than an unusual notation for a vector. We could have just denoted the states of a qubit by e.g.&nbsp;<span class="math inline">\(\vec{v_0}\)</span> and <span class="math inline">\(\vec{v_1}\)</span>, but I’ll keep the fancy Dirac notation.</p>
<p>In the quantum jargon, a linear combination of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> is called a <em>superposition</em>. The superposition principle states that (almost) any vector in the state space, i.e.&nbsp;any linear combination of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> is a valid state. The coefficients <span class="math inline">\(a_0\)</span> and <span class="math inline">\(a_1\)</span>, called <em>amplitudes</em>, can be positive or negative. (They can even be complex numbers, but negative amplitudes are sufficient to summon the quantum magic.)</p>
<p>As I will explain in a bit, the only constraint on the amplitudes is <span class="math inline">\(|a_0|^2+|a_1|^2=1\)</span>. In other words, the vector <span class="math inline">\(|\psi\rangle\)</span> needs to have a unit length. The states with real amplitudes can be nicely visualized as a point on a unit circle.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/state_circ.png" class="img-fluid figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>Amplitudes are simply projections of <span class="math inline">\(|\psi\rangle\)</span> on the corresponding axes: <span class="math inline">\(a_0=\cos\theta, a_1=\sin\theta\)</span>.</p>
<p>(In general, amplitudes can be complex numbers. Then, a state of a qubit is a point on the <a href="https://en.wikipedia.org/wiki/Bloch_sphere">Bloch sphere</a>. But restricting to states with real amplitudes is simpler and sufficient for our goals.)</p>
</section>
<section id="probabilistic-interpretation-of-superposition" class="level1">
<h1>Probabilistic interpretation of superposition</h1>
<p>Alright, but what does it mean for a qubit to be in a superposition of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>? In many ways, it is similar to saying that there is some probability that the qubit is in state <span class="math inline">\(|0\rangle\)</span>, and some probability it is in state <span class="math inline">\(|1\rangle\)</span>. Yet, there are crucial differences between a superposition, and a classical probability distribution, that eventually lead to the quantum speedups.</p>
<p>Let’s first discuss the similarities. Given a qubit in state <span class="math inline">\(|\psi\rangle=a_0|0\rangle+a_1|1\rangle\)</span>, we can <em>measure</em> it. The measurement result is a simple definite state of the qubit, either <span class="math inline">\(|0\rangle\)</span> or <span class="math inline">\(|1\rangle\)</span>. But the outcome is probabilistic. We get state <span class="math inline">\(|0\rangle\)</span> with probability <span class="math inline">\(p_0=|a_0|^2\)</span>, and state <span class="math inline">\(|1\rangle\)</span> with probability <span class="math inline">\(p_1=|a_1|^2\)</span>. Naturally, a valid quantum state must have <span class="math inline">\(p_0+p_1=1\)</span>. Any two amplitudes <span class="math inline">\(a_0\)</span> and <span class="math inline">\(a_1\)</span> satisfying <span class="math inline">\(|a_0|^2+|a_1|^2=1\)</span> define a valid state of a qubit.</p>
<p>If the only thing we do to state <span class="math inline">\(|\psi\rangle=a_0|0\rangle+a_1|1\rangle\)</span> is the measurement, then it is virtually indistinguishable from a probabilistic bit, which is <span class="math inline">\(0\)</span> with probability <span class="math inline">\(p_0=|a_0|^2\)</span> and <span class="math inline">\(1\)</span> with probability <span class="math inline">\(p_1=|a_1|^2\)</span>.</p>
<p>Before continuing, I need to make two technical remarks for later reference. Fist, note that as far as only the measurement results are concerned, all four states of the form <span class="math inline">\(|\psi\rangle=\pm a_0|0\rangle\pm a_1|1\rangle\)</span> are also indistinguishable (because they lead to identical probabilities of measurement outcomes). The relative sign of the amplitudes <span class="math inline">\(a_0\)</span> and <span class="math inline">\(a_1\)</span> may be important for other quantum processes, to be discussed later, but not for the measurement. Also, states <span class="math inline">\(|\psi\rangle\)</span> and <span class="math inline">\(-|\psi\rangle\)</span> are <em>always</em> indistinguishable, not only through measurement, but to any quantum process, and should be thought of as the same state.</p>
</section>
<section id="quantum-mechanics-is-a-theory-of-amplitudes" class="level1">
<h1>Quantum mechanics is a theory of amplitudes</h1>
<p>Now for the differences between a superposition and a probability distribution. Quantum mechanics is fundamentally a theory of amplitudes. While amplitudes give rise to probabilities of measurement outcomes, the amplitudes are primary. Quantum computations, and more generally quantum processes, transform amplitudes. You can not reduce quantum amplitudes to the probabilities they represent. In this section, I will give a simple example illustrating the crucial difference.</p>
<section id="quantum-processes" class="level2">
<h2 class="anchored" data-anchor-id="quantum-processes">Quantum processes</h2>
<p>Before going to the example, we need to discuss how quantum states change when we do something to them. A simple answer is as follows. Quantum states are vectors, and quantum processes linear transformations, or matrices, acting on these vectors.</p>
<p>What kind of matrices? Well, a single-qubit state is a point on a circle, and any quantum process should map it to another point on this circle. And there are only two options: rotations and reflections. A general qubit rotation is represented by</p>
<p><span class="math display">\[\begin{align}
U = \begin{pmatrix}\cos\theta &amp; \sin\theta \\ -\sin\theta &amp; \cos\theta \end{pmatrix} \ .
\end{align}\]</span></p>
<p>In Dirac’s notation this is equivalent to</p>
<p><span class="math display">\[\begin{align}
U|0\rangle = \cos\theta |0\rangle+\sin\theta |1\rangle,\quad U|1\rangle = -\sin\theta |0\rangle+\cos\theta |1\rangle \ .
\end{align}\]</span></p>
<p>As a reflection operator it is customary to choose</p>
<p><span class="math display">\[\begin{align}
Z=\begin{pmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix},\qquad \text{i.e.}\quad Z|0\rangle=|0\rangle, \quad Z|1\rangle=-|1\rangle \ .
\end{align}\]</span></p>
<p>Any single-qubit quantum process is equivalent to a combination of <span class="math inline">\(U\)</span> and <span class="math inline">\(Z\)</span>. These processes are often called <em>quantum gates</em>, by analogy with classical logic gates. For instance, setting <span class="math inline">\(\theta=\frac{\pi}{2}\)</span> and multiplying by <span class="math inline">\(Z\)</span> we get</p>
<p><span class="math display">\[\begin{align}
ZU(\pi/2) = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix} \begin{pmatrix} 0 &amp; 1 \\ -1 &amp; 0 \end{pmatrix} = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{pmatrix} \ ,
\end{align}\]</span> which is equivalent to the standard NOT gate, exchanging <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>.</p>
<p>Though not strictly necessary for what follows, I’ll try to motivate why quantum processes should be like that. That quantum processes must be rotations (or reflections, or, more generally, unitary transformations) of state vectors is a consequence of the following assumptions.</p>
<ol type="1">
<li>Quantum processes must be linear, meaning that <span class="math inline">\(U\left(a_0|0\rangle+a_1|1\rangle\right)=a_0U|0\rangle+a_1U|1\rangle\)</span>.</li>
<li>They should preserve the length of the state vectors.</li>
<li>They must be reversible.</li>
</ol>
<p>The assumption of linearity is very natural, and closely parallels the linearity of classical probability. Preserving the length of the state vector is necessary, because state vectors with non-unit length do not describe valid probability distributions. The last assumption of reversibility is a bit more subtle to explain. I’d like to emphasize that it is more of a convenience, rather than a necessity.</p>
<p>In principle, all processes in the physical world are reversible, either quantum or classical. Irreversibility appears when we discard some information. For example, an operation that resets the bit to value 0, is irreversible, because it “forgets” the initial state of the bit. But you can reset the state of a qubit to <span class="math inline">\(|0\rangle\)</span> just as well, and that would be an irreversible operation. (Simply measure that state of the qubit, and if it turns out <span class="math inline">\(|1\rangle\)</span>, apply NOT gate to it.)</p>
<p>For some reason, it is customary to use irreversible logic gates, such as AND or OR, in classical computing, but restrict to reversible logic gates in quantum computing. (In fact, it is possible to make any classical computation using reversible gates only.) My main point here is that this distinction is not fundamental.</p>
</section>
<section id="bit-flipping" class="level2">
<h2 class="anchored" data-anchor-id="bit-flipping">Bit flipping</h2>
<p>Now we are ready to explain by example how transforming probability amplitudes is fundamentally different from transforming probabilities.</p>
<p>Let’s call <span class="math inline">\(F\)</span> a procedure of taking a classical bit, and randomly flipping it. Say the bit was initially in <span class="math inline">\(0\)</span>. After flipping, it is <span class="math inline">\(0\)</span> or <span class="math inline">\(1\)</span> with equal probability, i.e.&nbsp;<span class="math inline">\(p_0=p_1=\frac12\)</span>. Let’s apply <span class="math inline">\(F\)</span> once more, e.g.&nbsp;flip the bit the second time. This results in the following possibility tree.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/prob_tree.png" class="img-fluid figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>There are two ways that the final state of the bit can turn out <span class="math inline">\(1\)</span>. The first is that the bit transitioned <span class="math inline">\(0\to 0 \to 1\)</span> and the second is a through a sequence <span class="math inline">\(0 \to 1 \to 1\)</span>. Each “history” or <em>trajectory</em> has probability <span class="math inline">\(\frac14 =\frac12\times\frac12\)</span>, so that the total probability to find the bit in state <span class="math inline">\(1\)</span> after applying <span class="math inline">\(F\)</span> twice is <span class="math inline">\(\frac12=\frac14+\frac14\)</span>.</p>
</section>
<section id="qubit-flipping" class="level2">
<h2 class="anchored" data-anchor-id="qubit-flipping">Qubit flipping</h2>
<p>Here is a quantum version of this scenario. There is a process called the Hadamard gate, denoted by <span class="math inline">\(H\)</span>, which acts as follows</p>
<p><span class="math display">\[\begin{align}
H|0\rangle = |+\rangle := \frac1{\sqrt{2}}\left(|0\rangle + |1\rangle\right), \quad H|1\rangle = |-\rangle := \frac1{\sqrt{2}}\left(|0\rangle - |1\rangle\right)  \ .
\end{align}\]</span></p>
<p>In words, <span class="math inline">\(H\)</span> takes state <span class="math inline">\(|0\rangle\)</span> to state <span class="math inline">\(|+\rangle\)</span>, proportional to the sum of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>, and takes <span class="math inline">\(|1\rangle\)</span> to <span class="math inline">\(|-\rangle\)</span>, the state proportional to their difference. The factors <span class="math inline">\(\frac1{\sqrt{2}}\)</span> ensure that amplitudes squared sum to one. Nota that <span class="math inline">\(H\)</span> gate is a rotation by angle <span class="math inline">\(\theta=\frac{\pi}{4}\)</span>.</p>
<p>If we simply measure them, states <span class="math inline">\(|+\rangle\)</span> and <span class="math inline">\(|-\rangle\)</span> are indistinguishable from each other. Both yield <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> with equal probabilities <span class="math inline">\(p_0=p_1=\frac12\)</span>. That’s why I say that <span class="math inline">\(H\)</span> is similar to our classical bit-flipping operation <span class="math inline">\(F\)</span>.</p>
<p>However, when applied twice, <span class="math inline">\(H\)</span> maps <span class="math inline">\(|0\rangle\)</span> back onto itself. Indeed <span class="math display">\[\begin{align}
H^2 |0\rangle=H \frac1{\sqrt{2}}\left(|0\rangle + |1\rangle\right) = \frac1{\sqrt{2}}\left(\frac{|0\rangle+|1\rangle}{\sqrt{2}}+\frac{|0\rangle-|1\rangle}{\sqrt{2}}\right)=|0\rangle \ .
\end{align}\]</span> There is <em>no chance</em> that the final state turns out <span class="math inline">\(|1\rangle\)</span>.</p>
<p>Let’s illustrate this graphically, using the same tree of possible trajectories.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/amp_tree.png" class="img-fluid figure-img" style="width:70.0%"></p>
</figure>
</div>
<p>Now the transitions are labeled by their amplitudes, instead of probabilities. As before, there are two ways to end up in state <span class="math inline">\(|1\rangle\)</span>, one going through intermediate state <span class="math inline">\(|0\rangle\)</span>, and one going through <span class="math inline">\(|1\rangle\)</span>. The amplitudes of these trajectories, however, have opposite signs, <span class="math inline">\(\frac12 = \frac1{\sqrt{2}}\times \frac1{\sqrt{2}}\)</span> and <span class="math inline">\(-\frac12=\frac1{\sqrt{2}}\times (-\frac1{\sqrt{2}})\)</span>, respectively. This makes the total amplitude, and hence the total probability, to end up in state <span class="math inline">\(|1\rangle\)</span> vanishing.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="coins.png" class="img-fluid figure-img" style="width:50.0%"></p>
</figure>
</div>
</section>
<section id="amplitudes-can-cancel-probabilities-cant" class="level2">
<h2 class="anchored" data-anchor-id="amplitudes-can-cancel-probabilities-cant">Amplitudes can cancel, probabilities can’t</h2>
<p>This is <em>the key</em> difference between classical and quantum. For a classical probabilistic process, the probabilities of different trajectories sum up. In other words, if there are several possibilities to reach an end state, they reinforce each other. In a quantum process, it is the amplitudes that sum up, and they can <em>cancel</em> each other. The fact that there is some trajectory (with a non-zero amplitude) leading to some end state, does not mean that this end state is in fact reachable. The amplitude of this trajectory can be canceled by others. This is known as a <em>quantum interference</em>. (If you are familiar, this is what the famous <a href="https://en.wikipedia.org/wiki/Double-slit_experiment">double-slit experiment</a> shows. Opening up a new slit for particles to pass through can <em>decrease</em> their chances of getting to a particular end point.)</p>
<p>Note that our choice to use <span class="math inline">\(H\)</span> gate in the example above is pretty arbitrary. It is simple and convenient, but almost any other quantum gate will lead to quantum interference, and that’s what essential.</p>
</section>
</section>
<section id="quantum-states-of-multiple-qubits" class="level1">
<h1>Quantum states of multiple qubits</h1>
<p>Before discussing why quantum interference can lead to quantum speedups, let’s address one more question. A general state of three qubits can be written as</p>
<p><span class="math display">\[\begin{align}
|\psi\rangle = a_{000}|000\rangle + a_{001}|001\rangle+a_{010}|010\rangle+a_{011}|011\rangle+a_{100}|100\rangle + a_{101}|101\rangle+a_{110}|110\rangle+a_{111}|111\rangle \ .
\end{align}\]</span></p>
<p>Notation <span class="math inline">\(|x_1x_2x_3\rangle \equiv |x_1\rangle |x_2\rangle |x_3\rangle\)</span> is a shorthand for saying that the first qubit is in state <span class="math inline">\(|x_1\rangle\)</span>, the second in state <span class="math inline">\(|x_2\rangle\)</span>, and the third in state <span class="math inline">\(|x_3\rangle\)</span>. The amplitudes here have the same meaning as for a single qubit. For instance, <span class="math inline">\(|a_{101}|^2\)</span> is the probability to find the first and third qubits in state <span class="math inline">\(|1\rangle\)</span>, and the second qubit in state <span class="math inline">\(|0\rangle\)</span>, upon measuring. For three qubits there are <span class="math inline">\(8\)</span> possible states, and <span class="math inline">\(8\)</span> amplitudes. For <span class="math inline">\(n\)</span> qubits, there are <span class="math inline">\(2^n\)</span> possible bitstrings and <span class="math inline">\(2^n\)</span> amplitudes (subject to the total probability equals one condition). This exponential dimension of the state space is often cited as <em>the origin</em> of the quantum speedups. Yet, it is only a part of the story.</p>
<p>Indeed, while the number of qubits <span class="math inline">\(n\)</span> is small enough, so that the dimension of the state space <span class="math inline">\(2^n\)</span> is manageable, any quantum process can be simulated classically. This is known as state-vector simulation, and it only requires being able to store and update a vector of dimension <span class="math inline">\(2^n\)</span> (currently, up to roughly <span class="math inline">\(n=50\)</span> qubits can be simulated by this brute-force approach.).</p>
<p>However, the mere exponential growth of the state space is not sufficient. We have the same growth in classical probabilistic description. Indeed, to specify the probability distribution over <span class="math inline">\(n\)</span> classical bits, one needs to provide <span class="math inline">\(2^n\)</span> probabilities corresponding to each possible bit string. For instance, to describe a probability distribution over three bits, one needs to specify eight probabilities <span class="math inline">\(p_{000}\)</span> through <span class="math inline">\(p_{111}\)</span>.</p>
</section>
<section id="why-quantum-interference-defies-classical-simulation" class="level1">
<h1>Why quantum interference defies classical simulation</h1>
<p>Now we are ready to explain why some quantum computations can not be efficiently simulated by a classical computer. Imagine a quantum computer that manipulates <span class="math inline">\(n\)</span> qubits. It runs a quantum algorithm that outputs a quantum state. This particular algorithm produces a quantum state that is not a superposition, but a particular bitstring such as <span class="math inline">\(|\psi\rangle=|00101\dots\rangle\)</span>. This bitstring <em>is</em> (or encodes) the solution to our problem. (Not all quantum algorithms are like that, but some are, to a good approximation.)</p>
<p>You should also think of a quantum algorithm as consisting of a number of simple quantum operations. (Say it is a sequence of <span class="math inline">\(H\)</span> and <a href="https://en.wikipedia.org/wiki/Toffoli_gate">Toffoli gates</a>, which are universal for quantum computation.) Mathematically, you can get the output state by taking the initial state, representing it as a vector, and applying matrices of various quantum gates constituting the algorithm to this vector. As discussed, this works for <span class="math inline">\(n\)</span> sufficiently small, but eventually breaks down because the memory required scales exponentially.</p>
<p>Let’s imagine a similar scenario in a classical probabilistic world. Someone comes up with a classical probabilistic algorithm that produces a correct result with probability 1. In fact, directly simulating this algorithm by keeping track of the probabilities of different bitstrings at all steps may be equally intractable, because the number of possible bitstrings is exponentially large. But we do not need to do that. We know that the algorithm outputs the correct solution with probability one, i.e.&nbsp;the correct solution is reached by <em>all</em> trajectories having a non-zero probability. We simply need to simulate a <em>single</em> such trajectory, and see where it ends up. Classical probabilities don’t cancel, they reinforce each other.</p>
<p>This does not work for quantum amplitudes. We can easily find a trajectory with a non-zero amplitude. But there is no guarantee that this trajectory leads to the correct end state, because its amplitude can get cancelled by other trajectories. Accounting for all possible trajectories, you can determine the true probability of reaching that particular end state. Of course, generally there are exponentially many trajectories, and this is not feasible. (Incidentally, this view gives a different simulation technique. Keeping track of the total state vector requires exponential memory, but is time-efficient. In contrast, the total amplitude for reaching a particular end state can be computed by summing trajectories one by one. This requires little memory, but an exponential number of steps.)</p>
<p>More generally, neither quantum nor classical probabilistic algorithms need to produce a definite bitsting. In general, different runs produce different results, corresponding to some probability distribution. In that case, the simulation should only be capable of producing individual outcomes, or <em>samples</em>, that are described by the same distribution. This is easy to achieve in the classical probabilistic case. We simply sample <em>one</em> trajectory at a time, period. Ultimately, this works because though we <em>describe</em> our system as if it could be in different states at the same time step, this only makes sense for different runs of the algorithm. During a single run, a classical system can really only be in a single state at a single time.</p>
<p>This does not work for quantum processes. Here, it does not suffice to sample one trajectory at a time, because different trajectories can interfere. In a sense, quantum systems can really be in several places at once.</p>
</section>
<section id="why-quantum-interference-leads-to-quantum-speed-ups" class="level1">
<h1>Why quantum interference leads to quantum speed ups</h1>
<p>We saw how quantum interference is a hindrance to a classical simulation. But why is it useful? How can it lead to quantum speedups? Unfortunately, I can’t give you a clear-cut explanation, but we can at least see how that works at examples. We will consider two quantum algorithms.</p>
<section id="deutschs-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="deutschs-algorithm">Deutsch’s algorithm</h2>
<p>Deutsch’s algorithm is one of the first and simplest, an archetypical quantum algorithm. It may look a bit fishy though, but we’ll discuss that later.</p>
<p>So you have a boolean function of a single bit <span class="math inline">\(f(x)\)</span> (i.e.&nbsp;<span class="math inline">\(f\)</span> takes 0 or 1 and returns 0 or 1). There are two mutually exclusive possibilities, either <span class="math inline">\(f(0)=f(1)\)</span>, or <span class="math inline">\(f(0) != f(1)\)</span>. In the first case, we call the function <em>balanced</em>. The goal is to find out whether <span class="math inline">\(f\)</span> is balanced.</p>
<p>Importantly, the function <span class="math inline">\(f\)</span> is a “black box” for us. We can only <em>query</em> this function, i.e.&nbsp;provide it with inputs and observe outputs. In complexity theory lingo we have <em>oracular access</em> to <span class="math inline">\(f\)</span>, i.e.&nbsp;we can query it, but can’t look inside.</p>
<p>How many queries to <span class="math inline">\(f\)</span> should we make to figure out if <span class="math inline">\(f(0)\)</span> is the same as <span class="math inline">\(f(1)\)</span>? Right, two queries, one to find <span class="math inline">\(f(0)\)</span> and another to find <span class="math inline">\(f(1)\)</span>, there is no other way.</p>
<p>Turns out, we can solve the problem with a <em>single</em> query on a quantum computer. For this we need a quantum version of the oracle. The quantum oracle will be a matrix, denoted by <span class="math inline">\(U_f\)</span>, that works as follows</p>
<p><span class="math display">\[\begin{align}
U_f|x\rangle = (-1)^{f(x)}|x\rangle \ ,
\end{align}\]</span></p>
<p>i.e.&nbsp;the oracle reverses the sign of a state <span class="math inline">\(|x\rangle\)</span> if <span class="math inline">\(f(x)=1\)</span>. This definition might look a bit unnatural. A more obvious choice would be to say that the oracle acts by <span class="math inline">\(\widetilde{U}_f|x\rangle = |f(x)\rangle\)</span>. The problem is, if <span class="math inline">\(f(0)=f(1)\)</span> this <span class="math inline">\(\widetilde{U}_f\)</span> is not reversible, which is a problem for a quantum computer. <span class="math inline">\(U_f\)</span>, on the other hand, is always reversible. While this definition of <span class="math inline">\(U_f\)</span> may not be the first thing that comes to mind, it’s really the simplest way to define a transformation that treats states with <span class="math inline">\(f(x)=0\)</span> and <span class="math inline">\(f(x)=1\)</span> differently, while being reversible.</p>
<p>Recall that <span class="math inline">\(U_f\)</span> is a linear operator, so it acts on a state in superposition as</p>
<p><span class="math display">\[\begin{align}
U_f\left(a_0 |0\rangle+a_1|1\rangle\right) = a_0 (-1)^{f(0)}|0\rangle+a_1 (-1)^{f(1)}|1\rangle \ .
\end{align}\]</span></p>
<p>We are done with preliminaries. Here is the Deutsh algorithm. Start with <span class="math inline">\(|0\rangle\)</span> and apply <span class="math inline">\(H\)</span> gate to it, to obtain <span class="math inline">\(|+\rangle\)</span>. Then, apply the oracle to get</p>
<p><span class="math display">\[\begin{align}
U_fH|0\rangle = U_f |+\rangle = \frac1{\sqrt{2}}\left((-1)^{f(0)}|0\rangle + (-1)^{f(1)}|1\rangle\right)
\end{align}\]</span></p>
<p>You see, this state sort of knows both <span class="math inline">\(f(0)\)</span> and <span class="math inline">\(f(1)\)</span>. But this information can not be extracted directly. Simply measuring this state will give <span class="math inline">\(|0\rangle\)</span> or <span class="math inline">\(|1\rangle\)</span> with equal probabilities, and reveal nothing about <span class="math inline">\(f\)</span> whatsoever. The trick is to apply <span class="math inline">\(H\)</span> once again. With a little algebra, we find</p>
<p><span class="math display">\[\begin{align}
HU_fH|0\rangle = \frac12\left((-1)^{f(0)}+(-1)^{f(1)}\right)|0\rangle+\frac12\left((-1)^{f(0)}-(-1)^{f(1)}\right)|1\rangle \ .
\end{align}\]</span></p>
<p>This expression may look complicated, but is in fact trivial. For balanced functions only the first term survives, so that the final state is <span class="math inline">\(|0\rangle\)</span>, while for unbalanced functions the first term disappears, leaving us with <span class="math inline">\(|1\rangle\)</span>. (Formally, we can also get <span class="math inline">\(-|0\rangle\)</span> or <span class="math inline">\(-|1\rangle\)</span>, but recall that <span class="math inline">\(|\psi\rangle\)</span> and <span class="math inline">\(-|\psi\rangle\)</span> are in fact the same states.)</p>
<p>Hence, measuring the final state allows us to decide whether the function is balanced or not. And the final state is produced using <em>a single query</em> to the quantum oracle <span class="math inline">\(U_f\)</span>. Note that the crucial part of the computation is quantum interference, the cancellation between different trajectories. For balanced functions, <span class="math inline">\(U_f\)</span> is equivalent to the identity, and the amplitude of getting <span class="math inline">\(|1\rangle\)</span> in the end state is vanishing (this is literally our qubit-flipping example, with <span class="math inline">\(H\)</span> gate applied twice). The twist is that for the unbalanced functions, the situation is opposite.</p>
<p>The Deutsch algorithm solves an artificial problem and has no applications. Hiding some trivial function <span class="math inline">\(f\)</span> (after all, there are only four one-bit boolean functions!) in a “black box” might look silly. However, the techniques used generalize to meaningful problems, one of which we consider next.</p>
</section>
<section id="grovers-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="grovers-algorithm">Grover’s algorithm</h2>
<section id="quantum-search" class="level3">
<h3 class="anchored" data-anchor-id="quantum-search">Quantum search</h3>
<p><em>Grover’s</em> algorithm is one of the oldest, most famous, and simplest to explain quantum algorithms. It is often described as a <em>quantum search</em>.</p>
<p>Suppose there is a problem with a very large yet finite number of potential solutions, and you know no better way to find the right one other than trying all available options one by one. An example often given is trying to find a name of a person in a phone book, only knowing the phone number.</p>
<p>Mathematically, let <span class="math inline">\(f\)</span> be a boolean function of <span class="math inline">\(n\)</span> bits <span class="math inline">\(f(x_1, \dots, x_n)\)</span>. The goal is to find an assignment of bits that makes <span class="math inline">\(f(x_1,\dots, x_n)=1\)</span>. For simplicity, assume that such an assignment is unique, and call the corresponding solution <span class="math inline">\(m=(x_1,\dots, x_n)\)</span>, <span class="math inline">\(m\)</span> for marked state.</p>
<p>In the standard setting of Grover’s algorithm we only have oracular access to <span class="math inline">\(f\)</span>, i.e.&nbsp;we can provide it with inputs and observe outputs. (We will move beyond oracles, eventually.) In that case, there is nothing better we can do except for trying all of <span class="math inline">\(2^n\)</span> possible bitstrings <span class="math inline">\((x_1,\dots, x_n)\)</span> one by one, and see which one works. Let’s denote the total number of bitstrings by <span class="math inline">\(N=2^n\)</span>. On average, classical brute-force search takes <span class="math inline">\(N/2\)</span> queries to <span class="math inline">\(f\)</span>.</p>
</section>
<section id="grovers-oracle" class="level3">
<h3 class="anchored" data-anchor-id="grovers-oracle">Grover’s oracle</h3>
<p>Grover’s algorithm allows solving this search problem with only <span class="math inline">\(\sim \sqrt{N}\)</span> queries to the quantum oracle, a quadratic speedup relative to the classical search. Recall that an oracle <span class="math inline">\(U_m\)</span> for state <span class="math inline">\(|m\rangle\)</span> is some linear operator that differentiates this state from the rest. There may be different yet equivalent ways to define such an oracle. Perhaps, the most convenient one is</p>
<p><span class="math display">\[\begin{align}
U_m|x\rangle = (-1)^{f(x)} |x\rangle  = \begin{cases} -|m\rangle,\quad x=m \\ {\,\,\,\,\,}|x\rangle,\quad else \end{cases} \ ,
\end{align}\]</span></p>
<p>i.e.&nbsp;the oracle that reverses the sign of the marked stated <span class="math inline">\(|m\rangle\)</span>, and does nothing to the rest. To be sure, there is no quantum magic at this step, just a simple definition.</p>
</section>
<section id="the-initial-state" class="level3">
<h3 class="anchored" data-anchor-id="the-initial-state">The initial state</h3>
<p>In the first step of Grover’s algorithm (and in fact in many others) we prepare a state</p>
<p><span class="math display">\[\begin{align}
|s\rangle = \frac1{\sqrt{N}}\sum_x |x\rangle \ ,
\end{align}\]</span> which is a superposition of <em>all possible</em> bitstrings with equal amplitudes. Here are some examples. For <span class="math inline">\(n=1\)</span> state <span class="math inline">\(|s\rangle\)</span> is the same as state <span class="math inline">\(|+\rangle\)</span> we’ve met before. For <span class="math inline">\(n=2\)</span> we have <span class="math inline">\(|s\rangle = \frac12\left(|00\rangle+|01\rangle+|10\rangle+|11\rangle \right)\)</span>.</p>
<p>State <span class="math inline">\(|s\rangle\)</span> may look complicated, but it is easy to prepare. Simply apply <span class="math inline">\(H\)</span> gate to all qubits initialized in <span class="math inline">\(|0\rangle\)</span>. For instance, for <span class="math inline">\(n=2\)</span> we have <span class="math inline">\(H|0\rangle H|0\rangle = \frac1{\sqrt{2}}\left(|0\rangle+|1\rangle\right)\frac1{\sqrt{2}}\left(|0\rangle+|1\rangle\right)=\frac12\left(|00\rangle+|01\rangle+|10\rangle+|11\rangle \right)=|s\rangle\)</span>. There is a simple probabilistic analog of this state – a state of <span class="math inline">\(n\)</span> classical bits with any bitstring configuration being equally likely. And this probabilistic version is equally simple to prepare, just flip <em>every</em> bit randomly.</p>
</section>
<section id="reflections" class="level3">
<h3 class="anchored" data-anchor-id="reflections">Reflections</h3>
<p>Grover’s oracle <span class="math inline">\(U_m\)</span> has a simple geometric interpretation. Acting on any state <span class="math inline">\(|\psi\rangle\)</span>, it inverts its component along the marked state <span class="math inline">\(|m\rangle\)</span>. This is nothing but a reflection with respect to the hyperplane orthogonal to <span class="math inline">\(|m\rangle\)</span>. Thus, Grover’s oracle is a reflection in state space.</p>
<p>The final ingredient to Grover’s algorithm is a second reflection, around state <span class="math inline">\(|s\rangle\)</span>, which we denote by <span class="math inline">\(U_s\)</span>. I emphasize that <span class="math inline">\(|s\rangle\)</span> is a known state, which is easy to prepare. I will omit the details, but applying the corresponding reflection operator <span class="math inline">\(U_s\)</span> is straightforward and efficient.</p>
</section>
<section id="two-dimensional-subspace" class="level3">
<h3 class="anchored" data-anchor-id="two-dimensional-subspace">Two-dimensional subspace</h3>
<p>A neat feature of the Grover algorithm is that although it formally operates in an exponentially large space, the state of a system never escapes a two-dimensional subspace spanned by vectors <span class="math inline">\(|m\rangle\)</span> and <span class="math inline">\(|s\rangle\)</span>. Note that states <span class="math inline">\(|m\rangle\)</span> and <span class="math inline">\(|s\rangle\)</span> are not completely orthogonal, as <span class="math inline">\(|s\rangle\)</span> contains a small component along <span class="math inline">\(|m\rangle\)</span> with amplitude <span class="math inline">\(\frac1{\sqrt{N}}\)</span>. It is convenient to define state <span class="math inline">\(|s_\perp\rangle\)</span>, which is equal to <span class="math inline">\(|s\rangle\)</span> minus the component along <span class="math inline">\(|m\rangle\)</span>, and normalized to have unit length</p>
<p><span class="math display">\[\begin{align}
|s_\perp\rangle = \sqrt{\frac{N}{N-1}}\left(|s\rangle - \frac{1}{\sqrt{N}}|m\rangle\right) \ .
\end{align}\]</span></p>
<p>Here is a sketch.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/states.png" class="img-fluid figure-img" style="width:50.0%"></p>
</figure>
</div>
<p>Note that the angle <span class="math inline">\(\theta_0\)</span> is such that <span class="math inline">\(\sin\theta_0=\frac{1}{\sqrt{N}}\)</span>, a projection of <span class="math inline">\(|s\rangle\)</span> on <span class="math inline">\(|m\rangle\)</span>. For large <span class="math inline">\(N\)</span>, <span class="math inline">\(\theta_0\approx \frac{1}{\sqrt{N}}\)</span>.</p>
</section>
<section id="grovers-algorithm-is-a-sequence-of-small-rotations" class="level3">
<h3 class="anchored" data-anchor-id="grovers-algorithm-is-a-sequence-of-small-rotations">Grover’s algorithm is a sequence of small rotations</h3>
<p>So here is how Grover’s algorithm works. Start in state <span class="math inline">\(|s\rangle\)</span>, and apply two reflections, first <span class="math inline">\(U_m\)</span>, then <span class="math inline">\(U_s\)</span>. A combination of two reflections is a rotation, and turns out this is a rotation <em>towards</em> the marked state <span class="math inline">\(|m\rangle\)</span>. To find out the angle <span class="math inline">\(\theta\)</span> of this rotation, it is sufficient to track a single vector, say the initial state <span class="math inline">\(|s\rangle\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/grover_seq.png" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
<p>At the first step we apply <span class="math inline">\(U_m\)</span> and inverse the horizontal component of <span class="math inline">\(|s\rangle\)</span>. At the second step, we apply <span class="math inline">\(U_s\)</span>, which inverses the component along <span class="math inline">\(|s\rangle\)</span>. This leads to a vector pointing southwest. Recall that state <span class="math inline">\(|\psi\rangle\)</span> is the same as state <span class="math inline">\(-|\psi\rangle\)</span>, so we can multiply the resulting state by <span class="math inline">\(-1\)</span>, to compare more easily with the initial state <span class="math inline">\(|s\rangle\)</span>. Please assure yourself that the angle <span class="math inline">\(\theta\)</span> between the final state <span class="math inline">\(-U_s U_m |s\rangle\)</span> and the initial state <span class="math inline">\(|s\rangle\)</span> is twice the original angle <span class="math inline">\(\theta=2\theta_0\)</span>. For large <span class="math inline">\(N\)</span>, we have <span class="math inline">\(\theta\approx \frac{2}{\sqrt{N}}\)</span>.</p>
<p>That’s it! A single iteration of Grover’s algorithm rotates the initial state towards <span class="math inline">\(|m\rangle\)</span> by angle <span class="math inline">\(\theta\approx \frac{2}{\sqrt{N}}\)</span>. To reach the marked state <span class="math inline">\(|m\rangle\)</span>, we need to make the sequence of these small rotations that combine into a <span class="math inline">\(\frac{\pi}{2}\)</span> rotation, and the required number of iterations <span class="math inline">\(k\)</span>, which are all identical, is (roughly)</p>
<p><span class="math display">\[\begin{align}
k = \frac{\pi}{2 \theta} = \frac{\pi \sqrt{N}}{4} \ .
\end{align}\]</span> You see the <span class="math inline">\(\sqrt{N}\)</span> dependence right there, and this is surely better asymptotically than any classical algorithm can do. (Incidentally, no quantum algorithm can beat <span class="math inline">\(\sqrt{N}\)</span> for unstructured search as well.)</p>
<p>Just to be sure, rotating some known state <span class="math inline">\(|x\rangle\)</span> towards another known state <span class="math inline">\(|y\rangle\)</span>, by any angle, is trivial. The point of the Grover algorithm is that using the oracle, we can rotate towards the <em>unknown</em> state, yet only by a small angle at a time.</p>
<p>I glossed over many details here, such as explaining how to construct <span class="math inline">\(U_s\)</span>, proving why <span class="math inline">\(U_sU_m\)</span> is a rotation in 2d subspace, finding the exact value of <span class="math inline">\(k\)</span> which has edge-cases, etc. However, these are merely technical details, and if you followed along, you now understand the main idea behind Grover’s search.</p>
</section>
<section id="infinitesimal-quantum-speedup" class="level3">
<h3 class="anchored" data-anchor-id="infinitesimal-quantum-speedup">Infinitesimal quantum speedup</h3>
<p>Let’s now try to trace the speedup provided by Grover’s algorithm to quantum interference. For this, I’ll look at a single iteration alone, which already provides a kind of quantum speedup, similar to that of the Deutsch algorithm</p>
<p>Here is what I mean. Suppose you are only allowed to call the oracle once. How much does that increase your chances of finding the marked element? Classically, the best thing you can do is to call the oracle on a random input. If it turns out to be the solution, which happens with probability <span class="math inline">\(\frac1N\)</span>, you are done. If not, which happens with probability <span class="math inline">\(\frac{N-1}{N}\)</span>, you make a guess at some other of <span class="math inline">\(N-1\)</span> remaining bitstrings, which succeeds with probability <span class="math inline">\(\frac{1}{N-1}\)</span>. The total probability of success is</p>
<p><span class="math display">\[\begin{align}
p = \frac1{N}+\frac{N-1}{N}\frac1{N-1}= \frac{2}{N} \ .
\end{align}\]</span></p>
<p>This is basically equivalent to being able to guess twice.</p>
<p>Now, using a single call to the quantum oracle is equivalent to making 9 classical guesses! Indeed, recall that we begin in a state <span class="math inline">\(|s\rangle\)</span>, which contains every bitstring with amplitude <span class="math inline">\(\frac{1}{\sqrt{N}}\)</span>. Measuring <span class="math inline">\(|s\rangle\)</span> directly results it probability <span class="math inline">\(\frac{1}{N}\)</span> of finding the marked state <span class="math inline">\(m\)</span>, which is no better than a simple classical guess. However, after a single iteration of Grover’s algorithm, the angle becomes <span class="math inline">\(\theta_0+\theta=3\theta_0\)</span>, so that the amplitude of the marked state is <span class="math inline">\(\sin{3\theta_0}\approx \frac{3}{\sqrt{N}}\)</span>, which means that measuring this state now has probability <span class="math inline">\(\frac{9}{N}\)</span> to reveal the marked state.</p>
</section>
<section id="quantum-interference" class="level3">
<h3 class="anchored" data-anchor-id="quantum-interference">Quantum interference</h3>
<p>The “single-iteration quantum advantage” discussed above can be traced back to the quantum interference the same way we did before. Here is an illustration.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figs/grover_tree.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
<p>Alright, I’m not entirely sure these kinds of sketches are very useful at this point. I just wanted to emphasize that the same basic phenomenon that we have seen with quantum coin-flipping, and then with Deutsch’s algorithm, is also at play here. After a single Grover iteration, there are two ways to reach an undesirable state <span class="math inline">\(|s_\perp\rangle\)</span>, which have amplitudes with opposite signs. (One is <span class="math inline">\(\cos\theta_0\cos\theta\)</span>, the other <span class="math inline">\(-\sin\theta_0\sin\theta\)</span>, and the sum is <span class="math inline">\(\cos(\theta_0+\theta)\)</span>.) This kind of mutual weakening of different ways to reach an undesirable outcome is simply not possible in classical physics.</p>
</section>
<section id="beyond-oracles" class="level3">
<h3 class="anchored" data-anchor-id="beyond-oracles">Beyond oracles</h3>
<p>I promised to address the notion of the oracles, if you feel uncomfortable about them. Oracles are useful abstractions. Formulating Grover’s search in terms of oracles, or black boxes, is convenient. We estimate the complexity of the algorithm by simply counting the number of queries to the oracle.</p>
<p>In a real problem (e.g.&nbsp;<a href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem">3-SAT</a> or <a href="https://en.wikipedia.org/wiki/Circuit_satisfiability_problem">CircuitSAT</a>) function <span class="math inline">\(f\)</span> is likely to be given as some classical logical circuit. Because a quantum computer can do classical computations, it is merely a technical step to build the corresponding quantum operator. So equating a single call to the quantum oracle with a single call to the classical oracle is reasonable.</p>
<p>However, there is a catch with oracles. Given an actual function <span class="math inline">\(f\)</span>, and not just a black-box access, it could be possible to find solutions classically faster than in <span class="math inline">\(\sim N\)</span> steps. Whether the quantum speedup persists for such problems might be a tricky question, and should be analyzed with care. For some problems, at least, Grover’s search <em>does</em> provide an unconditional quantum speedup.</p>
</section>
</section>
</section>
<section id="faq" class="level1">
<h1>FAQ</h1>
<p>Instead of a conclusion, here is a FAQ. Alright, this is not a real FAQ, but rather a mix of some questions that I had, some questions I think you might have, and multiple tangents cut off from the main text.</p>
<section id="oh-my-who-reads-posts-this-long-gimme-tldr." class="level2">
<h2 class="anchored" data-anchor-id="oh-my-who-reads-posts-this-long-gimme-tldr.">Oh my, who reads posts this long? Gimme TLDR.</h2>
<p>You are right, nobody reads post this long. Here is a TLDR.</p>
<p>Quantum mechanics is a kind of probability theory. A quantum computation can be roughly thought of as a sequence of random events. In contrast to the classical random processes though, where different possibilities to reach <em>the same</em> outcome can only reinforce each other (their probabilities sum up), in quantum mechanics different possibilities can <em>interfere</em>, they can negate each other. This is one way to argue why quantum processes can not be efficiently simulated classically, and the interference of undesirable outcomes is necessary for quantum speedups.</p>
</section>
<section id="why-didnt-you-say-anything-about-electrons-superconductors-schrödinger-cats" class="level2">
<h2 class="anchored" data-anchor-id="why-didnt-you-say-anything-about-electrons-superconductors-schrödinger-cats">Why didn’t you say anything about electrons, superconductors, Schrödinger cats?</h2>
<p>From a mathematical point of view, quantum mechanics is not at all about physics, it is about how probabilities, or rather amplitudes, transform. It is of course truly remarkable that the physical world is ultimately quantum, but you do not need to study any particular physical system to understand quantum computing, as long as you’re not building quantum hardware.</p>
</section>
<section id="i-thought-quantum-computers-are-powered-by-quantum-entanglement" class="level2">
<h2 class="anchored" data-anchor-id="i-thought-quantum-computers-are-powered-by-quantum-entanglement">I thought quantum computers are powered by quantum entanglement!</h2>
<p>It is not that clear. It is true that any quantum computation without (with little) entanglement can be efficiently simulated classically. On the other hand, there is a <a href="https://en.wikipedia.org/wiki/Gottesman%E2%80%93Knill_theorem">very interesting</a> class of quantum algorithms that can be simulated efficiently despite generating tons of entanglement.</p>
<p>In general, surprisingly many quantum processes <em>can</em> be efficiently simulated classically. Often this happens because these processes only explore a tiny part of the exponentially large state space. If an algorithm produces no entanglement, it is easy to pinpoint this small part and navigate it classically. But just how special entanglement is in this respect is up to a debate, I think.</p>
</section>
<section id="what-about-classical-interference" class="level2">
<h2 class="anchored" data-anchor-id="what-about-classical-interference">What about classical interference?</h2>
<p>You’ve said the key player is quantum interference, right? What about classical interference, like waves, you know?</p>
<p>It is actually a pretty valid question. For instance, Grover himself <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.65.032319">considered</a> a possible analog of the quantum search using classical oscillators. You can also read an interesting discussion on <a href="https://physics.stackexchange.com/questions/732637/grovers-algorithm-using-wave-interference-for-computing">stack exchange</a>.</p>
<p>The main difference with classical interference is the dimension of state space. In classical physics, it is roughly proportional to the number of degrees of freedom that you have. In quantum physics, it is the exponent of that. So, in the classical world, we can have both the interference (waves) and an exponentially large space (in probabilistic setting), but not at the same time. In quantum, they co-exist.</p>
</section>
<section id="what-use-is-grovers-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="what-use-is-grovers-algorithm">What use is Grover’s algorithm?</h2>
<p>It’s hard to say, really. As far as I know, nobody is waiting for a quantum computer specifically to do some unstructured search. I mean, theoretically this is a remarkable algorithm, but its practical use cases are not clear.</p>
<p>Also, Grover’s algorithm only provides a quadratic speed-up over classical. Any quantum algorithm that is not exponentially better than a classical counterpart may actually never be useful in practice. Here is why.</p>
</section>
<section id="what-about-errors" class="level2">
<h2 class="anchored" data-anchor-id="what-about-errors">What about errors?</h2>
<p>Qubits are very fragile and easy to disturb, error rates comparable to classically estimated values like <span class="math inline">\(10^{-18}\)</span> are unimaginable for qubits. There is a principled way to deal with this, quantum error correction. The problem is, you need <em>a lot</em> of resources to produce a single fault-tolerant qubit. Current estimates show that the full error correction can lead to <span class="math inline">\(10^{10}\)</span>, ten <em>orders</em> difference between the speed of a quantum and a classical computer per elementary operation.</p>
<p>While this is “only” a constant factor, irrelevant for asymptotic performance, it may severely limit the practical usefulness of any quantum algorithm with sub-exponential speedup (see e.g.&nbsp;<a href="https://arxiv.org/abs/2011.04149">here</a>). There is a cool concept of <a href="https://en.wikipedia.org/wiki/Galactic_algorithm">galactic algorithms</a>, and some quantum algorithms may end up there.</p>
</section>
<section id="alright-what-other-quantum-algorithms-are-there" class="level2">
<h2 class="anchored" data-anchor-id="alright-what-other-quantum-algorithms-are-there">Alright, what other quantum algorithms are there?</h2>
<p>While there are tons of derivative quantum algorithms, the essential building blocks for them are only a few. Peter Shor himself wrote an essay at some point titled <a href="https://doi.org/10.1145/602382.602408">“Why haven’t more quantum algorithms been found?”</a>. The essay dates back to early 00’, but arguably the only innovation since was the HHL algorithm for solving linear systems.</p>
<p>So, roughly, there are these classes of algorithms.</p>
<ol type="1">
<li>Grover’s search and its extensions.</li>
<li>Those using the quantum Fourier transform to find periodicity. The best known example is Shor’s algorithm, allowing to factor integers in polynomial time.</li>
<li>Solving linear systems of equations, and performing other primitives of linear algebra.</li>
<li>Quantum simulation, using quantum computers to simulate other quantum systems (e.g.&nbsp;chemicals or materials).</li>
</ol>
<p>Except for the Grover, all other promise exponential speedups, and should be feasible even when the cost of error correction is factored in.</p>
</section>
<section id="what-is-the-killer-app" class="level2">
<h2 class="anchored" data-anchor-id="what-is-the-killer-app">What is the killer app?</h2>
<p>This one is difficult, I think we don’t know yet. I argued about this in detail in <a href="https://idnm.github.io/blog/posts/what_to_do_with_a_quantum_computer/what_to_do_with_a_quantum_computer.html">another post</a>.</p>
<p>Briefly, here are some of the problems.</p>
<ol type="1">
<li>We are not sure what to use Grover for, and it may not be feasible to run with error correction.</li>
<li>Factoring numbers efficiently and breaking RSA sounds cool, but has very limited practical use.</li>
<li>Quantum computers can efficiently implement linear algebra, e.g.&nbsp;solve linear systems, <em>if</em> we do not take into account the time necessary to load classical data to the quantum computer, and then read off the result. This limitation is <a href="https://scottaaronson.blog/?p=2196">totally serious</a>, and so far has not been addressed.</li>
</ol>
<p>Generally, there is a kind of trade-off. If there is very little structure to the problem, quantum algorithms can only give modest speedups, like Grover’s. Problems with a lot of structure are often efficiently solvable on a classical computer as well. Finding a sweet spot in between is really difficult. Shor’s factoring algorithm is still the only end-to-end example of an exponential quantum speedup.</p>
<p>Overall, right now quantum computing might be a “solution looking for a problem”. Our best short-term shot may be at using quantum computers to simulate other quantum systems, e.g.&nbsp;for quantum chemistry computations.</p>
</section>
<section id="how-long-before-quantum-chatbots" class="level2">
<h2 class="anchored" data-anchor-id="how-long-before-quantum-chatbots">How long before quantum chatbots?</h2>
<p>Totally unclear. Maybe there will be no quantum machine learning on classical data at all (see the previous question). There are some interesting proposals in this domain, but no clear established applications, even for future robust quantum computers.</p>
</section>
<section id="what-else-can-i-read" class="level2">
<h2 class="anchored" data-anchor-id="what-else-can-i-read">What else can I read?</h2>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/bb5bb628-1-image.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption"><a href="https://www.smbc-comics.com/comic/the-talk-3">source</a></figcaption><p></p>
</figure>
</div>
<p>Here are some references you might find interesting.</p>
<ul>
<li>A <a href="https://www.smbc-comics.com/comic/the-talk-3">comic</a> explaining some basics of quantum mechanics, co-authored by Scott Aaronson. Entertaining, and has <em>all</em> technical details 100% correct.</li>
<li>A brief and very pedagogical intro to quantum computing from Michael Nielsen <a href="https://quantum.country/">quantum country</a>.</li>
<li>While writing this post, I stumbled upon this talk <a href="https://www.youtube.com/watch?v=F_Riqjdh2oM&amp;t=2755s&amp;ab_channel=MicrosoftResearch">Quantum Computing for Computer Scientists</a>. I didn’t watch it fully, but the outline looks like a very nice introduction to quantum computing, partly overlapping and partly complementing with my post.</li>
<li>An intro to quantum computing by Veritasium, specifically addressing Shor’s algorithm <a href="https://www.youtube.com/watch?v=-UrdExQW0cs&amp;t=1002s&amp;ab_channel=Veritasium">How Quantum Computers Break The Internet… Starting Now</a>.</li>
<li>A game <a href="https://lab.quantumflytrap.com/game">quantum flytrap</a>. Among many quantum games out there, I especially liked this one, because it precisely simulates quantum behavior of photons. In fact, the game is built on top of a real optical table simulator.</li>
</ul>
<p>Alright, that’s it for this post. As usual, any feedback is appreciated!</p>



</section>
</section>

<div class="quarto-listing quarto-listing-container-default" id="listing-listing">
<div class="list quarto-listing-default">

</div>
<div class="listing-no-matching d-none">
No matching items
</div>
</div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="idnm/blog" data-repo-id="R_kgDOJWB1vg" data-category="General" data-category-id="DIC_kwDOJWB1vs4CVvR7" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>