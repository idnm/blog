<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Is quantum advantage looking under a lamppost?">

<title>Notes on Quantum Computing - What would I do with a quantum computer?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../kika.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-listing .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-date','listing-title','listing-description','listing-categories','listing-image',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-file-modified-sort'] }],
      
      searchColumns: [],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-listing'] = new List('listing-listing', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1154MLY31V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1154MLY31V', { 'anonymize_ip': true});
</script>
<script>
window.MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Notes on Quantum Computing</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">What would I do with a quantum computer?</h1>
                  <div>
        <div class="description">
          Is quantum advantage looking under a lamppost?
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#types-of-quantum-algorithms" id="toc-types-of-quantum-algorithms" class="nav-link" data-scroll-target="#types-of-quantum-algorithms">Types of quantum algorithms</a></li>
  <li><a href="#what-about-the-quantum-advantage-experiments" id="toc-what-about-the-quantum-advantage-experiments" class="nav-link" data-scroll-target="#what-about-the-quantum-advantage-experiments">What about the quantum advantage experiments?</a></li>
  <li><a href="#nisq-algorithms-dont-work" id="toc-nisq-algorithms-dont-work" class="nav-link" data-scroll-target="#nisq-algorithms-dont-work">NISQ algorithms don’t work</a>
  <ul class="collapse">
  <li><a href="#variational-quantum-algorithms" id="toc-variational-quantum-algorithms" class="nav-link" data-scroll-target="#variational-quantum-algorithms">Variational quantum algorithms</a></li>
  <li><a href="#quantum-machine-learning" id="toc-quantum-machine-learning" class="nav-link" data-scroll-target="#quantum-machine-learning">Quantum machine learning</a></li>
  <li><a href="#noisy-summary" id="toc-noisy-summary" class="nav-link" data-scroll-target="#noisy-summary">Noisy summary</a></li>
  </ul></li>
  <li><a href="#error-correction-eats-polynomial-speedups" id="toc-error-correction-eats-polynomial-speedups" class="nav-link" data-scroll-target="#error-correction-eats-polynomial-speedups">Error correction eats polynomial speedups</a></li>
  <li><a href="#breaking-rsa-is-not-a-big-deal" id="toc-breaking-rsa-is-not-a-big-deal" class="nav-link" data-scroll-target="#breaking-rsa-is-not-a-big-deal">Breaking RSA is not a big deal</a></li>
  <li><a href="#big-data-algorithms-are-tricky" id="toc-big-data-algorithms-are-tricky" class="nav-link" data-scroll-target="#big-data-algorithms-are-tricky">Big data algorithms are tricky</a></li>
  <li><a href="#quantum-simulation" id="toc-quantum-simulation" class="nav-link" data-scroll-target="#quantum-simulation">Quantum simulation</a>
  <ul class="collapse">
  <li><a href="#quantum-dynamics" id="toc-quantum-dynamics" class="nav-link" data-scroll-target="#quantum-dynamics">Quantum dynamics</a></li>
  <li><a href="#quantum-phase-estimation" id="toc-quantum-phase-estimation" class="nav-link" data-scroll-target="#quantum-phase-estimation">Quantum phase estimation</a></li>
  </ul></li>
  <li><a href="#final-remarks" id="toc-final-remarks" class="nav-link" data-scroll-target="#final-remarks">Final remarks</a>
  <ul class="collapse">
  <li><a href="#what-have-i-missed" id="toc-what-have-i-missed" class="nav-link" data-scroll-target="#what-have-i-missed">What have I missed?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This post will be a bit different from others, in that I’ll try to give a high level review instead of diving in detail into a specific topic. Also, since this is my personal blog, I figured I will give some personal background on this one.</p>
<p>I got involved in the field of quantum computing relatively recently, in 2021. Before that, I didn’t even know the field exists, let alone is taking off at the industrial scale. Yes, that’s how robust my bubble was. After switching to quantum, I’ve tried to catch up on many levels – from understanding the fundamentals, to getting up to speed with state of the art in hardware and algorithms, to carrying out some original research. Although I made some progress in all directions, you can imagine how fragmented and incomplete my picture of the field is. While there is still a ton of topics I’d like to understand better, one particular question have been sitting on the back of my mind for quite a while. <strong><em>What quantum computers will actually be good for?</em></strong></p>
<p>Asking ChatGPT this precise question I got a pretty long list (click to unfold).</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled" title="Sure, here's a numbered list of some potential applications of quantum computers:">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Sure, here’s a numbered list of some potential applications of quantum computers:
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<ol type="1">
<li>Cryptography: Quantum computers have the potential to break many of the currently used encryption methods and could be used to develop new, more secure encryption methods that are resistant to quantum attacks.</li>
<li>Optimization: Quantum computers could be used to solve optimization problems exponentially faster than classical computers, potentially revolutionizing industries ranging from finance to transportation to healthcare.</li>
<li>Chemistry and materials science: Quantum computers can simulate the behavior of molecules and materials at the quantum level, which could help in the development of new drugs and materials.</li>
<li>Machine learning and artificial intelligence: Quantum computers could potentially outperform classical computers in tasks such as image and speech recognition, which could have applications in areas such as autonomous vehicles and robotics.</li>
<li>Financial modeling: Quantum computers could be used to quickly analyze large amounts of financial data and predict stock prices or other market trends.</li>
<li>Supply chain optimization: Quantum computers could be used to optimize supply chain operations, such as routing and scheduling, to improve efficiency and reduce costs.</li>
<li>Weather forecasting: Quantum computers could be used to simulate complex weather patterns and improve the accuracy of weather forecasting.</li>
<li>Energy production: Quantum computers could be used to optimize energy production and distribution, potentially reducing energy costs and improving energy efficiency.</li>
<li>Particle physics: Quantum computers could be used to analyze data from particle accelerators and help physicists understand the behavior of particles at the subatomic level.</li>
<li>Transportation: Quantum computers could be used to optimize transportation networks, including traffic flow, route planning, and logistics.</li>
</ol>
</div>
</div>
</div>
<p>And indeed, all these topics, and many more, are frequently covered in popular discussions and even technical papers on quantum computing. Probably for an non-expert it would be nearly impossible critically sort through these and resist the impression that quantum computers will be good for everything (and soon!). However, my exposure to the field already made me skeptical about many of the usually proposed applications. And I felt a pressing need to sort this out for myself. I now feel like I’ve mostly done my homework on this one, and here is what I found. For most of applications people discuss, prospects are pretty bleak. And it seems there is a single clear favorite.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>As mentioned, my expertise in the field is limited. So take my assessment critically. I will cite many other sources, but of course they are subject to my selection bias. Also, I’m more than happy to be proven wrong, more tangible applications is better! Feel free to leave the feedback.</p>
</div>
</div>
</section>
<section id="types-of-quantum-algorithms" class="level1">
<h1>Types of quantum algorithms</h1>
<p>While there are great many specific versions of quantum algorithms (see a pretty comprehensive list at <span class="citation" data-cites="zoo">&nbsp;[<a href="#ref-zoo" role="doc-biblioref">1</a>]</span>), they can be divided in a small number of broad categories. Back in 2003 the one and only Peter Shor wrote a short essay “Why haven’t more quantum algorithms been found?” <span class="citation" data-cites="Shor2003">&nbsp;[<a href="#ref-Shor2003" role="doc-biblioref">2</a>]</span>. There he points out three main categories of quantum algorithms that were known to date.</p>
<ul>
<li>Those using the quantum Fourier transform to find periodicity. The most famous example is the integer factoring algorithm due to Shor himself.</li>
<li>Algorithms similar or derived from Grover’s search.</li>
<li>Algorithms for quantum simulation.</li>
</ul>
<p>By the way, if you are interested why haven’t more quantum algorithms been found, then according to Shor, it is probably because (1) quantum algorithms are so unusual that we do not have a good way to think about and invent them or (2) maybe there is just so much quantum algorithms, after all. You may wonder how much have changed in the past 20 years. Apparently, not that much. I would add three more positions to the list.</p>
<ul>
<li>HHL algorithm.</li>
<li>NISQ “algorithms”.</li>
<li>Algorithms for quantum data.</li>
</ul>
<p>To my understanding, the key new addition is the algorithm for solving linear systems of equations, discovered by Harrow, Hassidim and Lloyd and known as HHL algorithm. Another broad class of algorithms are NISQ algorithms, of which variational quantum algorithms (VQA) are the primary example. Finally, there is a new paradigm emerging which asks if we can do more with a quantum computer if our data is not classical, but quantum. I will discuss each of them in turn.</p>
<p>So, as far as I can tell, that’s basically it. Of course there have been a great deal of progress since 2003 in finding new applications for the existing primitives, refining their efficiency, and even building unifying frameworks (see e.g. <span class="citation" data-cites="Martyn2021">&nbsp;[<a href="#ref-Martyn2021" role="doc-biblioref">3</a>]</span>). But the broad classification outlined above still seems to apply.</p>
</section>
<section id="what-about-the-quantum-advantage-experiments" class="level1">
<h1>What about the quantum advantage experiments?</h1>
<p>Before going through the list sketched above, let’s briefly touch on the quantum advantage experiments. They certainly made a big splash, and it’s important to understand their place in the grand scheme of things. So far, four groups reported quantum advantage. The fist and most known result comes from Google <span class="citation" data-cites="Arute2019">&nbsp;[<a href="#ref-Arute2019" role="doc-biblioref">4</a>]</span>, then there were two academic groups in China <span class="citation" data-cites="Wu2021">&nbsp;[<a href="#ref-Wu2021" role="doc-biblioref">5</a>]</span>-<span class="citation" data-cites="Zhong2020">&nbsp;[<a href="#ref-Zhong2020" role="doc-biblioref">6</a>]</span>, and last year it was Xanadu <span class="citation" data-cites="Madsen2022">&nbsp;[<a href="#ref-Madsen2022" role="doc-biblioref">7</a>]</span>. All these quantum advantage experiments were in <em>sampling</em> tasks, meaning the goal was to sample from a certain probability distribution that is believed to be hard to sample from classically. While debates up to this day continue on whether these quantum advantage experiments can in fact be spoofed by a classical computer, I’m willing to assume that the sampling tasks of this kind give a real and short-term achievable quantum advantage.</p>
<p>The problem is, <em>no useful applications of these sampling tasks</em> are known. This claim may sound too strong, as there are papers proposing different uses. For example, here is a review from Xanadu on possible applications of the Gaussian Boson Sampling <span class="citation" data-cites="Bromley2019">&nbsp;[<a href="#ref-Bromley2019" role="doc-biblioref">8</a>]</span>. Unfortunately, these are only heuristics. I’m not familiar with this subfield in any technical detail, so my argument is a behavioral one. Since these sampling experiments are already available, there is a huge incentive to produce practical results or at least come up with strong theoretical proposals. And this does not seem to be happening. Until I’ll see a surge of activity in this a rea, I’ll assume that these sampling experiments are unfortunately not useful.</p>
<p>I must admit that this is bothering me. We found something, that quantum computers can do better than classical, why can’t we use it? There must be a way, right? If we can’t, is there a good explanation? I don’t know one, but my discomfort was a bit relieved after reading a perspective by Harrow and Montanaro <span class="citation" data-cites="Harrow2018">&nbsp;[<a href="#ref-Harrow2018" role="doc-biblioref">9</a>]</span>. There, they introduce sampling experiments as computational analogs of Bell’s experiments. Indeed, although <a href="https://idnm.github.io/blog/posts/entanglement/2021-07-12-entanglement.html">we know</a> that quantum correlations can be stronger than classical, this does not lead directly to useful applications. Alright, I’ll leave it at that.</p>
</section>
<section id="nisq-algorithms-dont-work" class="level1">
<h1>NISQ algorithms don’t work</h1>
<p>Noisy-Intermediate-Scale-Quantum (NISQ) algorithms <span class="citation" data-cites="Bharti2022">&nbsp;[<a href="#ref-Bharti2022" role="doc-biblioref">10</a>]</span> account for most of the prospective applications of quantum computing, or at least you can get such an impression. There are NISQ algorithms for almost everything – optimization, machine learning, simulation, and even NISQ versions of algorithms such as factoring or HHL. However, these “algorithms” are in fact heuristics that come with many theoretical and practical problems. Let’s take a closer look.</p>
<section id="variational-quantum-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="variational-quantum-algorithms">Variational quantum algorithms</h2>
<p>The main category of NISQ algorithms are variational quantum algorithms (VQA). The two most studied examples are Quantum Approximate Optimization Algorithm (QAOA) and Variational Quantum Eigensolver (VQE). QAOA mostly focuses on ground state preparation for classical Ising Hamiltonians, which in facts covers a huge range of problems related to combinatorial optimization. VQE typically addresses Hamiltonians that arise from physics or chemistry, but largely does the same thing. I think the line between different types of VQA is quite blurry.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Variational quantum algorithms" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Variational quantum algorithms
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Quite generally, variational quantum algorithms aim to find a low energy state of some Hamiltonian <span class="math inline">\(H\)</span>, that encodes the problem of interest. To do this, they start with a trivial quantum state <span class="math inline">\(|0\rangle\)</span> and apply a parameterized quantum circuit to it <span class="math inline">\(U(\phi)|0\rangle\)</span>. The resulting energy <span class="math display">\[E(\theta)=\langle0|U^\dagger(\phi)HU(\phi)|0\rangle\]</span> is minimized by adjusting parameters <span class="math inline">\(\theta\)</span> classically.</p>
<p>Parameterized quantum circuits <span class="math inline">\(U(\theta)\)</span> can be informed by the problem as in QAOA, which seeks to approximate the adiabatic evolution, or completely problem-agnostic as in Hardware-Efficient ansatze.</p>
</div>
</div>
</div>
<p>Here is my simple-minded and a bit cynic take on the idea behind variational quantum “algorithms”, which I think would be better called variational quantum heuristics. Real quantum algorithms (without quotes) typically require circuits that are very deep. The current generation of quantum devices is pretty inaccurate, errors in two-qubit gates are of the order of <span class="math inline">\(1\%\)</span>. If you apply many gates, there will be nothing but noise at the output, and the computation is not useful. VQA approach the problem as follows. Alright, we do not know algorithms with shallow circuits, but let’s try to build some. We’ll prepare a quantum circuit that is sufficiently shallow to have a non-zero signal to noise ratio, and introduce <em>parameters</em> in there. While we do not know if any values of these parameters correspond to a useful computation, let’s try to adjust them (classical optimization loop) so that the circuit does something useful.</p>
<p>I mean, it is not a bad idea, and in many respects similar to how classical machine learning works. The problem seems to be, the current hardware only allows circuits so shallow, that you may optimize them all you want, you still wont get interesting results. Another practical problem is that evaluation of the energy function <span class="math inline">\(E(\theta)\)</span> requires taking a ton of samples, which is slow and expensive. On the theoretical side, the loss landscape of most VQA appears to be pretty terrible, featuring barren plateaus and many bad local minimums. So even on a perfect hardware there are no guarantees for good results.</p>
</section>
<section id="quantum-machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="quantum-machine-learning">Quantum machine learning</h2>
<div class="callout callout-style-default callout-note callout-titled" title="Supervised quantum machine learning models" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Supervised quantum machine learning models
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A typical quantum model for a supervised learning task looks very similar to VQA instances described above <span class="math display">\[E(x,\theta)=\langle0|U^\dagger(x,\phi) H U(x,\phi)|0\rangle\]</span> where part of the parameters <span class="math inline">\(x\)</span> are now not model “weights”, but instead encode the training data. The rest of the parameters <span class="math inline">\(\theta\)</span> are to be optimized to yield a better loss <span class="math inline">\(E(x,\theta)\)</span>.</p>
</div>
</div>
</div>
<p>Quantum machine learning (QML) sounds quite fancy, but it shares much of the problems with VQA. Additional questions you might ask about QML models is whether can be superior to classical models at data encoding, expressivity, generalize better etc. To the best of my understanding, all claims that some QML models are somehow better than classical counterparts are heuristic, inconclusive, or only work for extremely artificial datasets. Moreover, let me quote a recent perspective <span class="citation" data-cites="Schuld2022">&nbsp;[<a href="#ref-Schuld2022" role="doc-biblioref">11</a>]</span> by Schuld and Killoran titled “Is quantum advantage the right goal for quantum machine learning?”</p>
<blockquote class="blockquote">
<p>Contrary to commercial expectations – machine learning may turn out to be one of the hardest applications to show a practical quantum advantage for.</p>
</blockquote>
<p>Why? By all means take a look at the paper if you are interested, but a short answer is that</p>
<blockquote class="blockquote">
<p>Quantum machine learning research is trying to beat large, high-performing algorithms for problems that are conceptually hard to study.</p>
</blockquote>
<p>In other words, classical machine learning is so it sets a very high bar; it’s hard to theoretically analyze how it works let alone prove quantum advantage; and we can’t collect any meaningful empirical data on QML because the hardware is too noisy yet.</p>
</section>
<section id="noisy-summary" class="level2">
<h2 class="anchored" data-anchor-id="noisy-summary">Noisy summary</h2>
<p>There are many more versions of NISQ algorithms beyond VQA and QML. However, they all come with significant challenges. I quote an extensive recent review <span class="citation" data-cites="Bharti2022">&nbsp;[<a href="#ref-Bharti2022" role="doc-biblioref">10</a>]</span></p>
<blockquote class="blockquote">
<p>At the moment of documenting this review, there is no known demonstration of industrially relevant quantum advantage.</p>
</blockquote>
<p>I would add that, to the best of my knowledge, there are also no theoretical guarantees that NISQ algorithms can lead to quantum advantage at all. If you feel like reading another critical review of NISQI recommend this article <span class="citation" data-cites="Sarma">&nbsp;[<a href="#ref-Sarma" role="doc-biblioref">12</a>]</span> by a renowned condensed matter physicist Sankar Das Sarmaar, and these youtube presentations by Owen Lockwood <span class="citation" data-cites="LockwoodNISQ">&nbsp;[<a href="#ref-LockwoodNISQ" role="doc-biblioref">13</a>]</span>-<span class="citation" data-cites="LockwoodQML">&nbsp;[<a href="#ref-LockwoodQML" role="doc-biblioref">14</a>]</span>, which I found quite instructive.</p>
<p>So, NISQ algorithms seemed like a low-hanging fruit, but despite all the work of the past years, useful applications have not been demonstrated. Even the industry now seems to become less optimistic about NISQ, and focus more on the fault-tolerant algorithms, and so will we.</p>
</section>
</section>
<section id="error-correction-eats-polynomial-speedups" class="level1">
<h1>Error correction eats polynomial speedups</h1>
<p>One of the earliest discovered, best known, and simplest to explain quantum algorithms is due to Lov Grover.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Grover's algorithm" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Grover’s algorithm
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Grover’s algorithm is often described as a search through an unstructured database. When there are <span class="math inline">\(N\)</span> entries and no structure to the database whatsoever, classically you need to make <span class="math inline">\(N/2\)</span> queries on average to find what are you looking for. Grover’s algorithm allows to use about <span class="math inline">\(\sqrt{N}\)</span> quantum queries, yielding a quadratic speed-up.</p>
</div>
</div>
</div>
<p>Although Grover’s algorithm is certainly one of the pillar results in quantum computing <span class="citation" data-cites="AaronsonGrover">&nbsp;[<a href="#ref-AaronsonGrover" role="doc-biblioref">15</a>]</span>, there are many ways to challenge its practical significance. Here I will focus on a particular one, associated with the cost of its fault-tolerant implementation. This line of attack is important because it applies to many other algorithms with polynomial speed-ups.</p>
<p>As discussed in the NISQ section, decohernce and gate errors make it impossible to run deep circuits on modern devices. Sure, we expect that the error rates will go down in the future, but even orders of magnitude improvements won’t be enough. The principle answer to this challenge is error correction and fault-tolerant computation. By encoding the logical states in many physical qubits it is possible to arbitrarily suppress effective error rates. Asymptotically, the overhead of error correction in terms of physical to logical qubit ratio is polylog, and looks insignificant. However, the constant factors involved can be a deal breaker. What follows below is my coarse rundown based on papers <span class="citation" data-cites="Babbush2020">&nbsp;[<a href="#ref-Babbush2020" role="doc-biblioref">16</a>]</span> and <span class="citation" data-cites="Hoefler2023">&nbsp;[<a href="#ref-Hoefler2023" role="doc-biblioref">17</a>]</span>.</p>
<p>In the dominating paradigm of fault-tolerant computing the bottleneck is in production of the magic states. Roughly, one magic state is consumed to perform a single non-trivial computational primitive such as the Toffoli gate. Producing a single magic state involves hundreds of physical qubits, several code cycles, and hence a lot of the classical cofmputing power to guide the behavior of the quantum system. Rough estimations show that executing a single Toffoli gate can be 10 <em>orders</em> of magnitude slower than executing the NAND gate, its classical counterpart. This looks troublesome, doesn’t it?</p>
<p>But won’t this huge constant factor become irrelevant for large enough problem sizes? After all, we have a quadratic speed-up. Yes it will, but you should also consider how big that problem will be. Because the quantum computer starts with this huge handicap, it will probably take it years of runtime to catch up with a classical solver. So the problem sizes where you would see the quantum advantage are so large, that you’d have to wait a long long time to solve them even with a quantum computer. So this scenario does not look practical, in the end.</p>
<p>With very optimistic projections of how quantum computing will progress, problems with higher polynomial speed-ups, say quartic, become to look feasible. However, it appears that problems with exponential speed-up are really our best bet, and so we turn to them.</p>
</section>
<section id="breaking-rsa-is-not-a-big-deal" class="level1">
<h1>Breaking RSA is not a big deal</h1>
<p>It was a true breakthrough by Shor to show that the integer factoring problem can be solved efficiently by a quantum computer, exponentially faster than with any known classical algorithm. While you’d still need a huge fault-tolerant machine to pull that out in practice <span class="citation" data-cites="Gidney2021">&nbsp;[<a href="#ref-Gidney2021" role="doc-biblioref">18</a>]</span>, Shor’s algorithm does defy most of the objections aplicable to other quantum algorithms.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Shor's algorithm" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Shor’s algorithm
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Shor’s algorithm allows to factor an integer into primes in time scaling polynomially with the number of digits. It is probably one of the harderst among the archetypical quantum algorithms to explain. However, the difficult part is entirely in the classical pre- and post-processing steps, where the factoring problem is reduced to finding a period of some function and factorization is extracted from an approximate solution.</p>
<p>The key quantum subroutine used is the quantum Fourier transform (QFT), which is simple to sketch. By definition, starting with a computational basis state <span class="math inline">\(|n\rangle\)</span> it prepares a linear combination of all basis states <span class="math inline">\(|m\rangle\)</span> with amplitudes given by the coefficients of the discrete Fourier transform.</p>
<p><span class="math display">\[QFT|n\rangle = \frac{1}{\sqrt{N}}\sum_{m\in\{0,1\}^N} e^{2\pi i \frac{nm}{N}}|m\rangle\]</span></p>
<p>Fourier transform of a periodic function is peaked at the values related to the period, so that eventually it exposes the information about the original prime factorization problem. The important part is that the quantum Fourier transform can be implemented efficiently, i.e.&nbsp;by a polynomially-sized quantum circuit.</p>
</div>
</div>
</div>
<p>The only problem – <em>it is not really useful</em>. Yes, you can break RSA, but so what? There are other encryption schemes that so far seem to be safe against quantum adversaries. Once the quantum computers of necessary scale are available, the cryptographic world will need to adjust, and there will be some potential for adventures in the meatime. But in the end, the impact will be quite limited. Quoting Matthias Troyer <span class="citation" data-cites="HPQC">&nbsp;[<a href="#ref-HPQC" role="doc-biblioref">19</a>]</span></p>
<blockquote class="blockquote">
<p>So factoring might fund most of the field now, it’s not a killer app in the end.</p>
</blockquote>
<p>Now, there are other applications of factoring beyond cracking RSA, as there are other period-finding algorithms exploiting QFT, but these are mostly very special number-theoretic problems. While useful in principle, they seem much too limited in scope to provide impact we expected from the quantum computing.</p>
</section>
<section id="big-data-algorithms-are-tricky" class="level1">
<h1>Big data algorithms are tricky</h1>
<p>There is a large class of quantum algorithms that can be broadly described as big data or (fault-tolerant) quantum machine learning algorithms. The initial inspiration and the key subroutine in many of them is provided by the HHL algorithm, allowing to efficiently solve large systems of linear equations.</p>
<div class="callout callout-style-default callout-note callout-titled" title="HHL algorithm" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
HHL algorithm
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>HHL is often described as an algorithm to solve linear system of <span class="math inline">\(N\)</span> equations</p>
<p><span class="math display">\[Ax=b\]</span></p>
<p>in time scaling as <span class="math inline">\(\log N\)</span>, providing an exponential speed-up over classical algorithms. This scaling really requires an explanation, since even writing down the full solution <span class="math inline">\((x_1,\dots, x_N)\)</span> would take <span class="math inline">\(O(N)\)</span> time and negate the speed-up.</p>
<p>HHL assumes that vector <span class="math inline">\(b\)</span> is loaded as available as a state <span class="math inline">\(|b\rangle\)</span> in <span class="math inline">\(\log N\)</span> dimensional Hilbert space, whose amplitudes encode the entries of <span class="math inline">\(b\)</span>. Similarly, the output of the algorithm is a state <span class="math inline">\(|x\rangle\)</span>, and not its individual amplitudes. To produce the solution, one needs to apply operator <span class="math inline">\(e^{-iAt}\)</span> which only allows an efficient quantum circuit for special types of matrices <span class="math inline">\(A\)</span>. Finally, the matrix <span class="math inline">\(A\)</span> needs to be well conditioned, meaning that the ratio of its highest to lowest eigenvalue is not too large (does not scale polynomially with <span class="math inline">\(N\)</span>).</p>
</div>
</div>
</div>
<p>There fundamental factors limiting applicability of the big data algorithms. My discussion here is mostly based on a short and wonderfully written commentary piece by Scott Aaronson, and you probably should read it instead. The big data quantum algorithms aim to provide an exponential speed-up to tasks like matrix inversion, which take polynomial time classically. Which means, quantum algorithms need to be done in logarithmic time. But in general, <span class="math inline">\(\log N\)</span> time is not even sufficient to read in the problem specification, say <span class="math inline">\(N\times N\)</span> matrix, or write out an solution, say an <span class="math inline">\(N\)</span>-dimensional vector.</p>
<p>Thus, big data algorithms assume that the initial data available as amplitudes of quantum states <span class="math inline">\(|\psi_0\rangle\)</span> in a Hilbert space of dimension <span class="math inline">\(\log N\)</span>, and output the solution of the same form <span class="math inline">\(|\psi\rangle\)</span>. Hence, you need a very efficient way to load or generate the input data in your quantum memory, and be able to read out interesting quantities from some expectation values of <span class="math inline">\(\psi\rangle\)</span> and not the detailed information of its amplitudes. An operator tranforming <span class="math inline">\(|\psi_0\rangle\)</span> to <span class="math inline">\(|\psi\rangle\)</span> also requires an efficient quantum circuit implementation and can not correspond, say, to a general <span class="math inline">\(N\times N\)</span> matrix. And then, after you’ve restricted the problem in all these ways, it’s getting harder to exclude that some classical algorithm can take advantage of all the additional structure and solve the problem equally fast.</p>
<p>While not insurmountable, these conditions are highly restrictive in practice. The HHL algorithm appeared in 2009, and in his 2015 essay Scott Aaronson mentiones only two (ans somewhat contrived) end-to-end proposals adressing all the caveats. Probably there are more today, but I do not know of a well-established useful big data problem that is just waiting for an appropriate fault-talerant machine to appear to rock the world. I’ll still mention an interesting recent proposal though, which aim to accelerate training of <em>classical</em> neural networks. I can’t resist to quote a somewhat __ passage from the paper though</p>
</section>
<section id="quantum-simulation" class="level1">
<h1>Quantum simulation</h1>
<section id="quantum-dynamics" class="level2">
<h2 class="anchored" data-anchor-id="quantum-dynamics">Quantum dynamics</h2>
<p>Quantum simulation is the application that is often cited as having kick-started the field. Quantum simulation is in a sense very natural, as it does not require a convoluted procedure to fold and squeeze a classical problem into a quantum domain. Instead, it looks at the task that is obviously quantum in origin, and proposes an efficient way to solve it with a quantum computer.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Quantum Simulation" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quantum Simulation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Quantum simulation is designed to take an initial quantum state <span class="math inline">\(|\psi_0\rangle\)</span> and carry out its evolution under some Hamiltonian <span class="math inline">\(H\)</span>, i.e.&nbsp;to find</p>
<p><span class="math display">\[|\psi(t)\rangle=e^{-iHt}|\psi_0\rangle \ .\]</span></p>
<p>For a Hamiltonian which is sparse, e.g.&nbsp;consists of not too many local terms <span class="math inline">\(H=\sum_k{H_k}\)</span>, one can use the Trotter-Suzuki approximation <span class="math inline">\(e^{(A+B)\Delta t}=e^{A\Delta t}e^{B\Delta t}+O(\Delta t^2)\)</span> to reduce the simulation of the full Hamiltonian <span class="math inline">\(H\)</span> over some small time period <span class="math inline">\(\Delta t\)</span> to a simulation of separate local terms, which is in principle straightforward</p>
<p><span class="math display">\[e^{-i H \Delta t}=\prod_k e^{-i H_k \Delta t}+O(\Delta t^2) \ .\]</span></p>
<p>Evolution over a finite time period <span class="math inline">\(t\)</span> can then be produced by a sequence of short evolutions <span class="math inline">\(e^{-iHt}=\left(e^{-iH\Delta t}\right)^{\frac{t}{\Delta t}}\)</span>. The error coming from “Trotterization” of each small time step can be reduced by making <span class="math inline">\(\Delta t\)</span> smaller, at the cost of increasing the circuit depth polynomially.</p>
</div>
</div>
</div>
<p>While numerous classical methods for simulating quantum systems have been developed, with great success in many cases, they are not sufficient in general. This is another important point about the simulation problem – the difficulty of the classical algorithms is well established, so quantum computer is really expected to make the difference here.</p>
<p>Is quantum simulation useful? I mean, it obviously is, but how exactly? There are definitely implications for fundamental science such as probing complicated quantum dynamics, new phases of matter, quantum chaos and so on. But what about about designing a high-temperature superconductor or a new battery? Unfortunately, I am not aware of rigorous connection between the ability to do quantum simulation and producing practically useful outcomes. So far it seems to be more about exploring the physics/chemistry with the new tools and beyond the regimes the current techniques allow. For this reason, it’s not clear that analog quantum simulators, which will be ultimately limited in their accuracy, will have applications beyond basic science <span class="citation" data-cites="Daley2022">&nbsp;[<a href="#ref-Daley2022" role="doc-biblioref">20</a>]</span>.</p>
</section>
<section id="quantum-phase-estimation" class="level2">
<h2 class="anchored" data-anchor-id="quantum-phase-estimation">Quantum phase estimation</h2>
<p>There is another flavor of quantum simulation that looks more deterministic in the results it can produce. The archetypical algorithm here is the quantum phase estmation (QPE).</p>
<div class="callout callout-style-default callout-note callout-titled" title="Quantum phase estimation" style="minimal">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quantum phase estimation
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Quantum phase estimation (QPE) allows to find eigenvalues and prepare eigenstates of a Halimiltonian <span class="math inline">\(H\)</span>, provided one can efficienntly implement controlled evolution operators <span class="math inline">\(e^{-iHt}\)</span>. Usually, QPE is formulated as an algorithm finding eigenvalues of a unitary operator <span class="math inline">\(U\)</span> given its eigenstate <span class="math inline">\(|\lambda\rangle\)</span> with an unknown eigenvalue. QPE proceeds by applying powers of <span class="math inline">\(U\)</span> (<span class="math inline">\(U, U^2, U^4,\dots\)</span>) to state <span class="math inline">\(|\lambda\rangle\)</span>, each controlled by its own auxilary qubit. The state of the auxilary qubits then contains a lot of information about <span class="math inline">\(\lambda\)</span>, roughly one bit of accuracy per qubit, and this information can be efficiently revealed after performing a quantum Fourier transfrom on the auxilary qubits.</p>
<p>If the original state <span class="math inline">\(|\psi\rangle\)</span> is not an eigenstate of <span class="math inline">\(U\)</span>, QPE performs a projective energy measurment yilding some energy value <span class="math inline">\(E\)</span> and the corresponding state <span class="math inline">\(|\lambda_E\rangle\)</span> with probability proportional to the overlap of <span class="math inline">\(|\langle\psi|\lambda_E\rangle|^2\)</span>.</p>
</div>
</div>
</div>
<p>Quantum phase estimation yields high-accuracy information about the eigenstates of a Hamiltonian. For many practical question of quantum checmistry this is crucial. A caveat here is that to learn about the ground and low-energy states, the initial state for QPE needs to have a sufficiently high overlap with them, which may be a real challenge in practice.</p>
</section>
</section>
<section id="final-remarks" class="level1">
<h1>Final remarks</h1>
<section id="what-have-i-missed" class="level2">
<h2 class="anchored" data-anchor-id="what-have-i-missed">What have I missed?</h2>
<ul>
<li>Hard to work with classical data</li>
<li>Quantum data is a possibility</li>
<li>Analog QC</li>
<li>Many omissions here</li>
<li>QC will do wonderful things, in the end</li>
<li>Simulating oscillators</li>
<li>Adiabatic computing</li>
</ul>
<p><span class="citation" data-cites="LockwoodNISQ">&nbsp;[<a href="#ref-LockwoodNISQ" role="doc-biblioref">13</a>]</span> <span class="citation" data-cites="LockwoodQML">&nbsp;[<a href="#ref-LockwoodQML" role="doc-biblioref">14</a>]</span></p>
<p><strong>Random notes</strong></p>
<ul>
<li>list</li>
<li>Make a mind map?</li>
<li>Is looking for quantum advantage akin to searching under a lamppost?</li>
<li>Operating on classical vs quantum data. Comparison vs complex numbers.</li>
<li>Variational algorithms, no guarantees.</li>
<li>QPE may fail because of state preparation.</li>
<li>Are boson&amp;other samplers useful?</li>
<li>Possibly a large gap between quantum advantage and useful quantum advantage</li>
</ul>
<p><strong>Classes of algorithms</strong></p>
<ul>
<li>Simulation</li>
<li>Quantum phase estimation</li>
<li>Unstructured search</li>
<li>Prime factoring and breaking crypto</li>
<li>Sampling</li>
<li>Solving linear systems</li>
</ul>
<p><strong>Gaps</strong></p>
<ul>
<li>Quantum RAM and macine learning</li>
</ul>
<p><strong>To read</strong></p>
<ul>
<li><a href="#Fedorov2022">Fedorov2022</a> <span class="citation" data-cites="Fedorov2022">&nbsp;[<a href="#ref-Fedorov2022" role="doc-biblioref">21</a>]</span></li>
<li><a href="#Bharti2022">Bharti2022</a> <span class="citation" data-cites="Bharti2022">&nbsp;[<a href="#ref-Bharti2022" role="doc-biblioref">10</a>]</span>
<ul>
<li>Just a single line on Bittel and Kliesh.</li>
</ul></li>
<li><a href="#Harrow2018">Harrow2018</a> <span class="citation" data-cites="Harrow2018">&nbsp;[<a href="#ref-Harrow2018" role="doc-biblioref">9</a>]</span>
<ul>
<li>Lamppost ~ crypto</li>
<li><blockquote class="blockquote">
<p>Supremacy experiments can be thought of as the computational analogue of Bell experiments.</p>
</blockquote></li>
</ul></li>
<li>Aaronson <span class="citation" data-cites="Aaronson2022">&nbsp;[<a href="#ref-Aaronson2022" role="doc-biblioref">22</a>]</span></li>
<li>Arrazola <span class="citation" data-cites="Arrazola">&nbsp;[<a href="#ref-Arrazola" role="doc-biblioref">23</a>]</span></li>
<li>Photons <span class="citation" data-cites="Li_2015">&nbsp;[<a href="#ref-Li_2015" role="doc-biblioref">24</a>]</span></li>
<li>Practical quantum advantage in quantum simulation <span class="citation" data-cites="Daley2022">&nbsp;[<a href="#ref-Daley2022" role="doc-biblioref">20</a>]</span>
<ul>
<li>ubbard model – still intractable</li>
<li><blockquote class="blockquote">
<p>As we note below, the ultimate quantitative limitation of an analogue system without error correction is set by the calibration accuracy of the model that is implemented—this is where fault-tolerant digital quan- tum simulation will eventually have an advantage in specified accu- racy and in the broader programmability for more complex models,</p>
</blockquote></li>
<li>This also makes quantum dynamics a particularly good example for identifying the regimes of practical quantum advantage, as quantum information scrambling gives good arguments that the states cannot be compressed in the way that is often possible for the lowest-energy states.</li>
</ul></li>
<li>Mckinsey 2023 report <span class="citation" data-cites="mckinsey2023">&nbsp;[<a href="#ref-mckinsey2023" role="doc-biblioref">25</a>]</span></li>
<li>[Shor2003] <span class="citation" data-cites="Shor2003">&nbsp;[<a href="#ref-Shor2003" role="doc-biblioref">2</a>]</span></li>
<li>Hoefler2023 <span class="citation" data-cites="Hoefler2023">&nbsp;[<a href="#ref-Hoefler2023" role="doc-biblioref">17</a>]</span></li>
</ul>
<p><strong>To watch</strong></p>
<ul>
<li>Matthias Troyer: “High Performance Quantum Computing” https://www.youtube.com/watch?v=Hkz_Sn5qYWg;
<ul>
<li>analog simulators not pow.enough.</li>
<li>Grover’s search, rly?</li>
<li>Factoring – will be useless in the end, not a killer app.</li>
<li>page rank – apparently no advantage</li>
<li>“Which means we need to substantially improve these algorithms and we need to find better problems” LOL</li>
</ul></li>
<li>Towards Practical Quantum Advantage | Quantum Colloquium https://www.youtube.com/watch?v=WY3htdKUGsA</li>
<li>Mindscape 153 | John Preskill on Quantum Computers and What They’re Good For https://www.youtube.com/watch?v=UYt4QG8iZ6U</li>
<li>Owen Lockwood https://www.youtube.com/watch?v=bELTWdQDtPs&amp;t=1896s&amp;ab_channel=OwenLockwood
<ul>
<li>Wy advantage in NISQ2 vs analogue simulators</li>
<li>Is tere advantage in FTQC</li>
<li>Cool economic remarks were to get em</li>
<li>Peter Sor more quantum algoritms</li>
</ul></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled" title="Grover's algorithm">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Grover’s algorithm
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Note that there are five types of callouts, including: <code>note</code>, <code>warning</code>, <code>important</code>, <code>tip</code>, and <code>caution</code>.</p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note callout-titled" title="Grover's algorithm">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Grover’s algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that there are five types of callouts, including: <code>note</code>, <code>warning</code>, <code>important</code>, <code>tip</code>, and <code>caution</code>.</p>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon callout-titled" title="Grover's algorithm">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Grover’s algorithm
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that there are five types of callouts, including: <code>note</code>, <code>warning</code>, <code>important</code>, <code>tip</code>, and <code>caution</code>.</p>
</div>
</div>




</section>
</section>

<div class="quarto-listing quarto-listing-container-default" id="listing-listing">
<div class="list quarto-listing-default">

</div>
<div class="listing-no-matching d-none">
No matching items
</div>
</div><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" role="list">
<div id="ref-zoo" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">S. Jordan, <em><a href="https://quantumalgorithmzoo.org/">Quantum Algorithm Zoo</a></em>, (2022).</div>
</div>
<div id="ref-Shor2003" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">P. W. Shor, <em><a href="https://doi.org/10.1145/602382.602408"><span class="nocase">Why haven’t more quantum algorithms been found?</span></a></em>, Journal of the ACM (JACM) <strong>50</strong>, 87 (2003).</div>
</div>
<div id="ref-Martyn2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">J. M. Martyn, Z. M. Rossi, A. K. Tan, and I. L. Chuang, <em><a href="https://doi.org/10.1103/PRXQuantum.2.040203"><span class="nocase">A Grand Unification of Quantum Algorithms</span></a></em>, PRX Quantum <strong>2</strong>, (2021).</div>
</div>
<div id="ref-Arute2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">F. Arute et al., <em><a href="https://doi.org/10.1038/s41586-019-1666-5"><span class="nocase">Quantum supremacy using a programmable superconducting processor</span></a></em>, Nature 2019 574:7779 <strong>574</strong>, 505 (2019).</div>
</div>
<div id="ref-Wu2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">Y. Wu et al., <em><a href="https://doi.org/10.1103/PhysRevLett.127.180501"><span class="nocase">Strong quantum computational advantage using a superconducting quantum processor</span></a></em>, Physical Review Letters <strong>127</strong>, (2021).</div>
</div>
<div id="ref-Zhong2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">H. S. Zhong et al., <em><a href="https://doi.org/10.1126/SCIENCE.ABE8770/SUPPL_FILE/ABE8770_ZHONG_SM.PDF"><span class="nocase">Quantum computational advantage using photons</span></a></em>, Science <strong>370</strong>, 1460 (2020).</div>
</div>
<div id="ref-Madsen2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">L. S. Madsen et al., <em><a href="https://doi.org/10.1038/s41586-022-04725-x"><span class="nocase">Quantum computational advantage with a programmable photonic processor</span></a></em>, Nature 2022 606:7912 <strong>606</strong>, 75 (2022).</div>
</div>
<div id="ref-Bromley2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">T. R. Bromley, J. M. Arrazola, S. Jahangiri, J. Izaac, N. Quesada, A. D. Gran, M. Schuld, J. Swinarton, Z. Zabaneh, and N. Killoran, <em><a href="https://doi.org/10.1088/2058-9565/ab8504"><span class="nocase">Applications of Near-Term Photonic Quantum Computers: Software and Algorithms</span></a></em>, Quantum Science and Technology <strong>5</strong>, (2019).</div>
</div>
<div id="ref-Harrow2018" class="csl-entry" role="listitem">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">A. W. Harrow and A. Montanaro, <em><a href="https://doi.org/10.1038/nature23458"><span class="nocase">Quantum computational supremacy</span></a></em>, Nature <strong>549</strong>, 203 (2017).</div>
</div>
<div id="ref-Bharti2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">K. Bharti et al., <em><a href="https://doi.org/10.1103/RevModPhys.94.015004"><span class="nocase">Noisy intermediate-scale quantum algorithms</span></a></em>, Reviews of Modern Physics <strong>94</strong>, 015004 (2022).</div>
</div>
<div id="ref-Schuld2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">M. Schuld and N. Killoran, <em><a href="https://doi.org/10.1103/PRXQuantum.3.030101"><span class="nocase">Is quantum advantage the right goal for quantum machine learning?</span></a></em>, PRX Quantum <strong>3</strong>, (2022).</div>
</div>
<div id="ref-Sarma" class="csl-entry" role="listitem">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">S. D. Sarma, <em><a href="https://www.technologyreview.com/2022/03/28/1048355/quantum-computing-has-a-hype-problem/">Quantum Computing Has a Hype Problem</a></em>, (2022).</div>
</div>
<div id="ref-LockwoodNISQ" class="csl-entry" role="listitem">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">O. Lockwood, <em><a href="https://www.youtube.com/watch?v=bELTWdQDtPs&amp;list=PL91jA61XuCIBrPUVXwG_2gVNYMqA7hrgi&amp;index=3">The Next Era of Quantum Computing: The End of NISQ and the Beginning of a New Phase</a></em>, (2022).</div>
</div>
<div id="ref-LockwoodQML" class="csl-entry" role="listitem">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">O. Lockwood, <em><a href="https://www.youtube.com/watch?v=ZDZc8bbe094&amp;list=PL91jA61XuCIBrPUVXwG_2gVNYMqA7hrgi&amp;index=2">What Is Quantum Machine Learning (QML) Good for Anyway? (OO)</a></em>, (2022).</div>
</div>
<div id="ref-AaronsonGrover" class="csl-entry" role="listitem">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">S. Aaronson, <em><a href="https://scottaaronson.blog/?p=7143">Of Course Grover’s Algorithm Offers a Quantum Advantage!</a></em>, (2023).</div>
</div>
<div id="ref-Babbush2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline">R. Babbush, J. McClean, M. Newman, C. Gidney, S. Boixo, and H. Neven, <em><a href="https://doi.org/10.1103/PRXQuantum.2.010103"><span class="nocase">Focus beyond quadratic speedups for error-corrected quantum advantage</span></a></em>, PRX Quantum <strong>2</strong>, (2020).</div>
</div>
<div id="ref-Hoefler2023" class="csl-entry" role="listitem">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline">T. Hoefler, T. Häner, and M. Troyer, <em><a href="https://doi.org/10.1145/3571725"><span class="nocase">Disentangling Hype from Practicality: On Realistically Achieving Quantum Advantage</span></a></em>, Communications of the ACM <strong>66</strong>, 82 (2023).</div>
</div>
<div id="ref-Gidney2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">C. Gidney and M. Ekerå, <em><a href="https://doi.org/10.22331/q-2021-04-15-433"><span class="nocase">How to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubits</span></a></em>, Quantum <strong>5</strong>, 433 (2021).</div>
</div>
<div id="ref-HPQC" class="csl-entry" role="listitem">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">M. Troyer, <em><a href="https://www.youtube.com/watch?v=Hkz_Sn5qYWg">High Performance Quantum Computing</a></em>, (2014).</div>
</div>
<div id="ref-Daley2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">A. J. Daley, I. Bloch, C. Kokail, S. Flannigan, N. Pearson, M. Troyer, and P. Zoller, <em><a href="https://doi.org/10.1038/s41586-022-04940-6"><span class="nocase">Practical quantum advantage in quantum simulation</span></a></em>, Nature 2022 607:7920 <strong>607</strong>, 667 (2022).</div>
</div>
<div id="ref-Fedorov2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">A. K. Fedorov, N. Gisin, S. M. Beloussov, and A. I. Lvovsky, <em><a href="http://arxiv.org/abs/2203.17181"><span class="nocase">Quantum computing at the quantum advantage threshold: a down-to-business review</span></a></em>, 1 (2022).</div>
</div>
<div id="ref-Aaronson2022" class="csl-entry" role="listitem">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">S. Aaronson, <em><a href="https://arxiv.org/abs/2209.06930v1 http://arxiv.org/abs/2209.06930"><span class="nocase">How Much Structure Is Needed for Huge Quantum Speedups?</span></a></em>, (2022).</div>
</div>
<div id="ref-Arrazola" class="csl-entry" role="listitem">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">J. M. Arrazola, <em><a href="https://medium.com/xanaduai/everything-you-always-wanted-to-know-about-quantum-inspired-algorithms-38ee1a0e30ef"><span class="nocase">Everything you always wanted to know about quantum-inspired algorithms | by Xanadu | XanaduAI | Medium</span></a></em>, (n.d.).</div>
</div>
<div id="ref-Li_2015" class="csl-entry" role="listitem">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">Y. Li, P. C. Humphreys, G. J. Mendoza, and S. C. Benjamin, <em><a href="https://doi.org/10.1103/physrevx.5.041007">Resource Costs for Fault-Tolerant Linear Optical Quantum Computing</a></em>, Physical Review X <strong>5</strong>, (2015).</div>
</div>
<div id="ref-mckinsey2023" class="csl-entry" role="listitem">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">McKinsey, <em><a href="https://www.mckinsey.com/capabilities/mckinsey-digital/our-insights/quantum-technology-sees-record-investments-progress-on-talent-gap?cid=soc-web#/">Quantum Technology Monitor</a></em>, (2023).</div>
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="idnm/blog" data-repo-id="R_kgDOJWB1vg" data-category="General" data-category-id="DIC_kwDOJWB1vs4CVvR7" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>