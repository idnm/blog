<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2021-07-12">
<meta name="description" content="I see, and so what?">

<title>Notes on Quantum Computing - What is entanglement?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../kika.jpeg" rel="icon" type="image/jpeg">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-listing .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-date','listing-title','listing-description','listing-categories','listing-image',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-file-modified-sort'] }],
      
      searchColumns: [],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-listing'] = new List('listing-listing', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1154MLY31V"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1154MLY31V', { 'anonymize_ip': true});
</script>
<script>
window.MathJax = {
  tex: {
    tags: 'ams'
  }
};
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Notes on Quantum Computing</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">What is entanglement?</h1>
                  <div>
        <div class="description">
          I see, and so what?
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">quantum concepts</div>
                <div class="quarto-category">qiskit</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 12, 2021</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#entanglement-is-the-failure-of-states-to-factorize" id="toc-entanglement-is-the-failure-of-states-to-factorize" class="nav-link" data-scroll-target="#entanglement-is-the-failure-of-states-to-factorize">Entanglement is the failure of states to factorize</a></li>
  <li><a href="#entangled-spin-behaves-very-differently-from-unentangled" id="toc-entangled-spin-behaves-very-differently-from-unentangled" class="nav-link" data-scroll-target="#entangled-spin-behaves-very-differently-from-unentangled">Entangled spin behaves very differently from unentangled</a></li>
  <li><a href="#entanglement-correlations-are-stronger-than-classical" id="toc-entanglement-correlations-are-stronger-than-classical" class="nav-link" data-scroll-target="#entanglement-correlations-are-stronger-than-classical">Entanglement correlations are stronger than classical</a></li>
  <li><a href="#final-remarks" id="toc-final-remarks" class="nav-link" data-scroll-target="#final-remarks">Final remarks</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><a target="_blank" href="https://colab.research.google.com/github/idnm/blog/blob/master/posts/entanglement/2021-07-12-Entanglement.ipynb"> <img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab" align="right"></a></p><a target="_blank" href="https://colab.research.google.com/github/idnm/blog/blob/master/posts/entanglement/2021-07-12-Entanglement.ipynb">
</a><p><a target="_blank" href="https://colab.research.google.com/github/idnm/blog/blob/master/posts/entanglement/2021-07-12-Entanglement.ipynb"></a></p>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>I’ve known the formal definition of entanglement for years, but I am only now appreciating many of its profound implications. In this post I would like to share two aspects that put entangled states into sharp contrast with unentangled (separable pure) states and classical random variables. Instead of proofs I provide references and simple experiments in <code>qiskit</code>.</p>
<center>
<img src="entangled_spins.svg" alt="Drawing" style="width: 300px;">
</center>
</section>
<section id="entanglement-is-the-failure-of-states-to-factorize" class="level1">
<h1>Entanglement is the failure of states to factorize</h1>
<p>So what is entanglement? Entanglement is what entangled states have. What are those? Take two spins. The state</p>
<p><span class="math display">\[\begin{align}
\frac1{\sqrt{2}}\Big(|\uparrow\uparrow\rangle+|\downarrow\downarrow\rangle\Big) \label{bell}
\end{align}\]</span> is your canonical example of an entangled stated. In contrast, all the states below are <em>unentangled</em> <span class="math display">\[\begin{align}
|\uparrow\uparrow\rangle,\qquad |\downarrow\uparrow\rangle,\qquad \frac1{\sqrt{2}}|\uparrow\rangle\Big(|\uparrow\rangle-|\downarrow\rangle\Big),\qquad \frac1{\sqrt{2}}\Big(|\uparrow\rangle-|\downarrow\rangle\Big)\Big(|\uparrow\rangle+|\downarrow\rangle\Big)  \label{unen}
\end{align}\]</span></p>
<p>The difference between <span class="math inline">\(\eqref{bell}\)</span> and <span class="math inline">\(\eqref{unen}\)</span> is the following. All latter states are actually <em>products</em> of the form <span class="math inline">\(|\psi_1\rangle |\psi_2\rangle\)</span> where <span class="math inline">\(|\psi_1\rangle\)</span> is the state of the first system and <span class="math inline">\(|\psi_2\rangle\)</span> of the second. In contrast, state <span class="math inline">\(\eqref{bell}\)</span> <em>can not</em> be represented in as a product. It is instead a linear combination of factorized states which is not reducible to a single product. You can <em>define</em> entangled states by this property of not being factorizible into states of consistuent spins.</p>
<p>Now that we know what entangled states are it is perfectly reasonable to ask: “<em>so what?</em>”. Why are entangled states special? I am going to give two angles on this questions, out of many possible.</p>
<hr>
<p>Note for the sake of concreteness and simplicity I talk about “spins”. In the context of discrete-variable quantum computation “spin”<span class="math inline">\(\equiv\)</span>“qubit”, but I prefer spins, because they come with a useful geometrical intuition. The abstract <a href="https://en.wikipedia.org/wiki/Bloch_sphere">Bloch sphere</a> associated to a qubit describes an actual orientation of a spin in <span class="math inline">\(3d\)</span> space.</p>
</section>
<section id="entangled-spin-behaves-very-differently-from-unentangled" class="level1">
<h1>Entangled spin behaves very differently from unentangled</h1>
<p>A spin which is not entangled can always be described by a direction <span class="math inline">\(\bf n\)</span> along which it is pointing <span class="math inline">\(|\uparrow_{\bf n}\rangle\)</span>. If one measures the component of the spin along this direction, the result is always <span class="math inline">\(\frac12\)</span>. Such a measurement corresponds to a projector <span class="math inline">\(P({\bf n})={\bf n}\cdot {\bf \sigma}=n_x \sigma_x+n_y\sigma_y+n_z\sigma_z\)</span>. If state <span class="math inline">\(|\uparrow_{\bf n}\rangle\)</span> is measured along a different axis <span class="math inline">\(\bf n'\)</span> the result depends on the angle <span class="math inline">\(\theta\)</span> between <span class="math inline">\(\bf n\)</span> and <span class="math inline">\(\bf n'\)</span>. With probability <span class="math inline">\(\cos^2\frac\theta2\)</span> one gets projection <span class="math inline">\(+\frac12\)</span> and with probability <span class="math inline">\(\sin^2\frac\theta2\)</span> one gets <span class="math inline">\(-\frac12\)</span>. However, for <strong>any</strong> state of the spin <span class="math inline">\(|\psi\rangle\)</span> <strong>there is</strong> an axis <span class="math inline">\(\bf n\)</span>, such that measuring the spin along this axis gives <span class="math inline">\(\frac12\)</span> with <strong>probability one</strong>.</p>
<p>This is also true for any of the unentangled states <span class="math inline">\(\eqref{unen}\)</span>. For example, measuring the projection of the first spin in the state <span class="math inline">\(|\uparrow\uparrow\rangle\equiv |\uparrow_{\bf z}\uparrow_{\bf z}\rangle\)</span> along <span class="math inline">\(\bf z\)</span> always gives <span class="math inline">\(+\frac12\)</span>. As another example, since <span class="math display">\[\begin{align}
|\downarrow_{\bf x}\rangle=\frac12\Big(|\uparrow_{\bf z}\rangle-|\downarrow_{\bf z}\rangle\Big) \label{xdown}
\end{align}\]</span> the state <span class="math inline">\(\frac1{\sqrt{2}}\Big(|\uparrow\rangle-|\downarrow\rangle\Big)\Big(\uparrow\rangle+|\downarrow\rangle\Big)\)</span> always registers <span class="math inline">\(-\frac12\)</span> when the projection of the first spin along <span class="math inline">\(\bf x\)</span> axis is measured.</p>
<p>In contrast, for the maximally entangled state <span class="math inline">\(\eqref{bell}\)</span> the axis with a definite projection of the first spin <strong>does not exist</strong>. In fact, for all intents and purposes, if you only look at observables associated with the first qubit, state <span class="math inline">\(\eqref{bell}\)</span> behaves as a statistical ensemble of states <span class="math inline">\(|\uparrow\rangle\)</span> and <span class="math inline">\(|\downarrow\rangle\)</span>, i.e.</p>
<p><span class="math display">\[\begin{align}
\frac1{\sqrt{2}}\Big(|\uparrow\uparrow\rangle+|\downarrow\downarrow\rangle\Big)\approx \cases{|\uparrow\rangle \text{ with probability $\frac12$}\\ |\downarrow\rangle \text{ with probability $\frac12$}} \label{bellapprox}
\end{align}\]</span></p>
<p>This means, for example, that projection onto <span class="math inline">\(\bf z\)</span> axis of the first spin is <em>completely</em> random: with probability <span class="math inline">\(\frac12\)</span> it behaves as <span class="math inline">\(|\uparrow\rangle\)</span> and gives projection <span class="math inline">\(+\frac12\)</span>, with probability <span class="math inline">\(\frac12\)</span> it behaves as <span class="math inline">\(|\downarrow\rangle\)</span> and gives projection <span class="math inline">\(-\frac12\)</span>. This is different from a coherent superposition of the up and down states, such as <span class="math inline">\(\eqref{xdown}\)</span>. Although state <span class="math inline">\(\eqref{xdown}\)</span> gives random results when measured along <span class="math inline">\(\bf z\)</span>, it gives certain results when measured along <span class="math inline">\(\bf x\)</span>. There is no such axis for state <span class="math inline">\(\eqref{bellapprox}\)</span>. In fact, the spin projection along <em>any</em> axis is completely random.</p>
<p>To prove this fact I would need to go into some details of how one does construct an ensemble from an entangled state. This is not at all difficult but I won’t do it here. I encourage an interested reader to consult John Preskill’s notes (<a href="http://www.theory.caltech.edu/~preskill/ph219/chap2_15.pdf">chapter 2.3</a>).</p>
<p>Instead, let me do a quick experimental check using <code>qiskit</code>. A Hadamard gate followed by a CNOT creates our state <span class="math inline">\(\eqref{bell}\)</span>:</p>
<div class="cell" data-scrolled="true" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit <span class="im">import</span> QuantumCircuit, BasicAer, execute</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> qiskit.visualization <span class="im">import</span> plot_histogram</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>qc <span class="op">=</span> QuantumCircuit(<span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>qc.h(<span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>qc.cx(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>qc.draw(output<span class="op">=</span><span class="st">'mpl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<p><img src="2021-07-12-Entanglement_files/figure-html/cell-2-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>To my knowledge, one can only measure in the computational basis in <code>qiskit</code>, i.e.&nbsp;only along <span class="math inline">\(\bf z\)</span> axis in our terminology. To measure a spin along some axis <span class="math inline">\(\bf n\)</span> we can instead rotate the spin itself, and then measure along <span class="math inline">\(\bf z\)</span> axis. Mathematically, if <span class="math inline">\({\bf n} = R^{-1} {\bf z}\)</span> for some rotation <span class="math inline">\(R\)</span> then <span class="math inline">\(\langle \uparrow_{\bf z}|P({\bf n})| \uparrow_{\bf z}\rangle=\langle \uparrow_{R{\bf z}}|P({\bf z})| \uparrow_{R{\bf z}}\rangle\)</span>.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># These parameters define an axis along which we will measure.</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Feel free to change them and see if the outcome distribution changes.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>theta, pi, lam <span class="op">=</span> <span class="fl">0.13</span>, <span class="fl">0.89</span>, <span class="fl">0.37</span> </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>qc.u(theta, pi, lam, <span class="dv">0</span>) <span class="co"># Rotate the qubit.</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>qc.measure(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Execute on a simulator and plot a histogram of the result.</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>backend <span class="op">=</span> BasicAer.get_backend(<span class="st">'qasm_simulator'</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> execute(qc, backend, shots<span class="op">=</span><span class="dv">1000</span>).result()</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>counts  <span class="op">=</span> result.get_counts(qc)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>plot_histogram(counts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<p><img src="2021-07-12-Entanglement_files/figure-html/cell-3-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The result looks like a fair sample from the uniform probability distribution. This means that projection on the axis we have specified is indeed random. You can try to change the axis and see if you can get a biased distribution (spoiler: you can not).</p>
</section>
<section id="entanglement-correlations-are-stronger-than-classical" class="level1">
<h1>Entanglement correlations are stronger than classical</h1>
<p>First let me note that although we talked about the first spin before, the state <span class="math inline">\(\eqref{bell}\)</span> is symmetric and everything equally applies to the second spin. Although the behavior of each of these spins is completely random, there are strong correlations between the them. If we can make local measurements on both spins the state <span class="math inline">\(\eqref{bell}\)</span> behaves as</p>
<p><span class="math display">\[\begin{align}
\frac1{\sqrt{2}}\Big(|\uparrow\uparrow\rangle+|\downarrow\downarrow\rangle\Big)\approx \cases{|\uparrow\uparrow\rangle \text{ with probability $\frac12$}\\ |\downarrow\downarrow\rangle \text{ with probability $\frac12$}} \label{bellapprox2}
\end{align}\]</span></p>
<p>So for example projections onto <span class="math inline">\(\bf z\)</span> axis of both spins are <em>always</em> the same, although random. Again, this in fact holds for <em>any</em> axis. Here is an experimental verification.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Building Bell's state.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>qc <span class="op">=</span> QuantumCircuit(<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>qc.h(<span class="dv">0</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>qc.cx(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Rotation of each qubit to simulate measurement along arbitary axis.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>theta, pi, lam <span class="op">=</span> <span class="fl">0.13</span>, <span class="fl">0.89</span>, <span class="fl">0.37</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>qc.u(theta, pi, lam, <span class="dv">0</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>qc.u(theta, pi, lam, <span class="dv">1</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>qc.measure([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Simulate and plot results.</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>backend <span class="op">=</span> BasicAer.get_backend(<span class="st">'qasm_simulator'</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> execute(qc, backend, shots<span class="op">=</span><span class="dv">2000</span>).result()</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>counts  <span class="op">=</span> result.get_counts(qc)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>plot_histogram(counts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<p><img src="2021-07-12-Entanglement_files/figure-html/cell-4-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>The result I get is almost certainly a uniform distribution of over <span class="math inline">\(00=|\uparrow_{\bf n}\uparrow_{\bf n}\rangle\)</span> and <span class="math inline">\(11=|\downarrow_{\bf n}\downarrow_{\bf n}\rangle\)</span> (you can change <span class="math inline">\(\bf n\)</span> by changing angles in the code), however I also get a tiny number of spurious counts for <span class="math inline">\(01\)</span> and <span class="math inline">\(10\)</span>, which is probably a bug, hm.</p>
<p>When seeing this for the first time there is definitely something to contemplate, like say an <a href="https://en.wikipedia.org/wiki/EPR_paradox#:~:text=The%20Einstein%E2%80%93Podolsky%E2%80%93Rosen%20paradox,by%20quantum%20mechanics%20was%20incomplete.">EPR paradox</a>. Spoiler: it is not possible to use these correlations for superluminal transmission of information, but they are still a valuable resource. I will discuss just one manifestation of these quantum correlations which has a very concrete operational interpretation – it allows a quantum team to play a certain probabilistic game better than any classical team could! Note that this is also basically <a href="https://en.wikipedia.org/wiki/Bell%27s_theorem">Bell’s theorem</a> in disguise.</p>
<p>So here is the setup. Alice and Bob are playing together against Charlie. Charlie sends random uncorrelated bits <span class="math inline">\(x\)</span> to Alice and <span class="math inline">\(y\)</span> to Bob. Admittedly, Charlie’s job is not very creative and nothing in his strategy can be changed. Now, in response to the obtained bits Alice produces her output bit <span class="math inline">\(a\)</span> and Bob his <span class="math inline">\(b\)</span>. Team A&amp;B wins if <span class="math inline">\(a\oplus b=x\land y\)</span> where <span class="math inline">\(\oplus\)</span> is XOR (sum modulo 2) and <span class="math inline">\(\land\)</span> is the logical AND. Explicitly, if <span class="math inline">\(x\land y=1\)</span> both Alice and Bob got <span class="math inline">\(x=y=1\)</span> (which happens one quarter of the time) and they win iff they respond <span class="math inline">\(a=0, b=1\)</span> or <span class="math inline">\(a=1, b=0\)</span> so that <span class="math inline">\(a\oplus b=1\)</span>. For all other inputs from Charlie, i.e.&nbsp;when <span class="math inline">\((x,y)\)</span> is equal to <span class="math inline">\((0,0), (1,0)\)</span> or <span class="math inline">\((0,1)\)</span> the logical sum <span class="math inline">\(x\land y=0\)</span> and Alice and Bob win iff <span class="math inline">\(a=0,b=0\)</span> or <span class="math inline">\(a=1, b=1\)</span> so that <span class="math inline">\(a\oplus b=0\)</span>.</p>
<p>Now, although in the same team, Alice and Bob are not allowed to communicate during the game. But they can discuss their strategy in advance. The best that a classical team can do is to win <span class="math inline">\(75\%\)</span> of the time. To achieve this winning rate it is sufficient to simply output <span class="math inline">\(a=0, b=0\)</span> irrespective of Charlie’s bits <span class="math inline">\(x,y\)</span>. This strategy only loses when <span class="math inline">\(x=y=1\)</span>, i.e.&nbsp;one quarter of the time.</p>
<p>Now comes the interesting part. If Alice and Bob each have a spin, and these spins are entangled as in state <span class="math inline">\(\eqref{bell}\)</span>, they can achieve the winning probability <span class="math display">\[\begin{align}
P_{win}= \frac12+\frac1{2\sqrt{2}}\approx 0.85! \label{pwin}
\end{align}\]</span> So, what should they do?</p>
<p>Define four axes <span class="math inline">\(\bf n_1,n_2,n_3,n_4\)</span> in the <span class="math inline">\(\bf xz\)</span> plane (of course this is just one of the possibilities). Take <span class="math inline">\({\bf n_1}= (1,0)\)</span>, then <span class="math inline">\({\bf n_2}=(\frac1{\sqrt{2}},\frac1{\sqrt{2}})\)</span> is counter-clockwise rotated by <span class="math inline">\(\pi/4\)</span> wrt to <span class="math inline">\(\bf n_1\)</span>; <span class="math inline">\({\bf n_3}=(0,1)\)</span> is rotated by <span class="math inline">\(\pi/2\)</span>; and finally <span class="math inline">\({\bf n_4}=(-\frac1{\sqrt{2}},\frac1{\sqrt{2}})\)</span> is rotated by <span class="math inline">\(3\pi/4\)</span>.</p>
<center>
<img src="axes.svg" alt="Drawing" style="width: 200px;">
</center>
<p>Now here is the strategy that Alice and Bob follow <span class="math display">\[\begin{align}
a(x)=\cases{P_{\bf n_3}, \qquad x=0 \\P_{\bf n_1}, \qquad x=1}\qquad\qquad b(y)=\cases{P_{\bf n_2}, \qquad y=0 \\P_{\bf n_4}, \qquad y=1} \label{abcases}
\end{align}\]</span></p>
<p>Where <span class="math inline">\(P_{\bf n}=+1\)</span> if Alice’s (or Bob’s) spin gave projection <span class="math inline">\(+\frac12\)</span> when measured along <span class="math inline">\(\bf n\)</span> and <span class="math inline">\(P_{\bf n}=0\)</span> if the projection was <span class="math inline">\(-\frac12\)</span>. An example: if Alice recieves <span class="math inline">\(x=0\)</span> and Bob <span class="math inline">\(y=1\)</span> Alice measures her spin along <span class="math inline">\(n_3=\bf z\)</span> axis and sends back the result, while Bob measures his spin along <span class="math inline">\(\bf{n_4}\)</span> (which is <span class="math inline">\(3\pi/4\)</span> rotated <span class="math inline">\(\bf x\)</span> axis) and sends his result.</p>
<p>Now, shall we check that this strategy indeed achieves the advertised winning probability <span class="math inline">\(\eqref{pwin}\)</span>? Sure, I also thought so!</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define rotation axes by their angles.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>theta1 <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>theta2 <span class="op">=</span> np.pi<span class="op">/</span><span class="dv">4</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>theta3 <span class="op">=</span> np.pi<span class="op">/</span><span class="dv">2</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>theta4 <span class="op">=</span> <span class="dv">3</span><span class="op">*</span>np.pi<span class="op">/</span><span class="dv">4</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> charlie():</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Charlies job is to generate two random bits.</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.random.randint(<span class="dv">0</span>,<span class="dv">1</span><span class="op">+</span><span class="dv">1</span>, size<span class="op">=</span>(<span class="dv">2</span>))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> alice(x):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Alice decides on the measurement axis according to her strategy.</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> theta3</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> theta1</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bob(x):</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bob does his part of the protocol.</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> theta2</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x<span class="op">==</span><span class="dv">1</span>:</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> theta4</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> one_round():</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First we prepare an entangled state.</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    qc <span class="op">=</span> QuantumCircuit(<span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    qc.h(<span class="dv">0</span>)</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    qc.cx(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now Charlie generates his bits.</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> charlie()</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A&amp;B team makes their move.</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    a_angle <span class="op">=</span> alice(x)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    b_angle <span class="op">=</span> bob(y)</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Again, we can not measure directly along the desired axes, </span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># but must rotate the qubits instead. Rotation in the xz plane is made by `ry` gate.</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    qc.ry(a_angle, <span class="dv">0</span>) <span class="co"># Alice rotates her qubit.</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    qc.ry(b_angle, <span class="dv">1</span>) <span class="co"># Bob his.</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now we add measurments and actually run the circuit.</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    qc.measure([<span class="dv">0</span>, <span class="dv">1</span>], [<span class="dv">0</span>, <span class="dv">1</span>])</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    backend <span class="op">=</span> BasicAer.get_backend(<span class="st">'qasm_simulator'</span>)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> execute(qc, backend, shots<span class="op">=</span><span class="dv">1</span>).result()</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    counts  <span class="op">=</span> result.get_counts(qc)</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Output of counts is a dict like `{'01': 1}`. This extracts the measurment results:</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    a, b <span class="op">=</span> [<span class="bu">int</span>(c) <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">list</span>(counts.keys())[<span class="dv">0</span>]]</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># And now we check, team A&amp;B gogogo!</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (a <span class="op">+</span> b) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> x <span class="op">*</span> y</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Alright, now let us collect the statistics:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>num_rounds <span class="op">=</span> <span class="dv">2000</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>wins <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_rounds):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    wins <span class="op">+=</span> one_round()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span> (<span class="st">"Win probability:</span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(wins<span class="op">/</span>num_rounds))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Win probability:0.847</code></pre>
</div>
</div>
<p>So that’s pretty close to the theoretical value <span class="math inline">\(\eqref{pwin}\)</span>. Note that for each round of the game a new entangled pair is needed.</p>
<p>Now that we have seen that the strategy <em>works</em> let us briefly discuss <em>why</em>. I will only give a sketch and refer for details to Preskill’s lectures <a href="http://theory.caltech.edu/~preskill/ph229/notes/chap4_01.pdf">chap 4.3</a>.</p>
<p>One thing Alice and Bob could do is to always measure along the same axes. Then, their results would be perfectly correlated (i.e.&nbsp;they always output <span class="math inline">\(a=b=0\)</span> or <span class="math inline">\(a=b=1\)</span>) which gives 0.75 winning probability, the same as the best deterministic strategy. Now, in one quarter of cases (when <span class="math inline">\(x=y=1\)</span>) they are better off outputting anticorrelated results. If we revisit the figure above equation <span class="math inline">\(\eqref{abcases}\)</span> we see that the angle between <span class="math inline">\(a(1)\)</span> and <span class="math inline">\(b(1)\)</span> is <span class="math inline">\(3\pi/4\)</span> which indeed gives a negative correlation in this case <span class="math inline">\(\Big(\cos \frac{3\pi}{4}=-\frac{1}{\sqrt{2}}\Big)\)</span>. The price to pay is that angles between <span class="math inline">\(\Big(a(0),b(0)\Big)\)</span>, <span class="math inline">\(\Big(a(0),b(1)\Big)\)</span> and <span class="math inline">\(\Big(a(1),b(0)\Big)\)</span> are now non-zero (and hence correlations are less than 1) which makes this strategy lose in some cases when the deterministic strategy wins. However, as we have seen experimentally the trade-off is still in our favor. It is also possible to prove that our choice of axes gives the maximum possible win probability. This is ultimately bound by Tsirelson’s bound, see below.</p>
<p>Now you might ask – what if there exists a clever randomized classical strategy which would perform better than deterministic 0.75 using a similar trick? Turns out this is not possible. The proof is based on the following inequality <span class="math display">\[\begin{align}
\Big|\langle a_0 b_0\rangle+\langle a_0 b_1\rangle+\langle a_1 b_0\rangle-\langle a_1 b_1\rangle\Big|\leq 2
\end{align}\]</span> which holds for any random variables <span class="math inline">\(a_0, a_1, b_0, b_1\)</span> taking values <span class="math inline">\(\pm1\)</span> and described by a joint probability distribution. This is known as <a href="https://en.wikipedia.org/wiki/CHSH_inequality">CHSH inequality</a> and a technical proof is trivial. Why quantum correlations do not have to obey the bound? Well, the reason is somewhat deep and quantum and ultimately related to Bohr’s <a href="https://en.wikipedia.org/wiki/Complementarity_(physics)">complementarity</a> – non-commuting observables can not be simultaneously assigned values. That this statement has quantitative consequences is illustrated by Bell’s theorem or our game.</p>
<p>Tehcnically quantum correlations obey the <a href="https://en.wikipedia.org/wiki/Tsirelson%27s_bound">Tsirelson’s bound</a> <span class="math display">\[\begin{align}
\Big|\langle a_0 b_0\rangle+\langle a_0 b_1\rangle+\langle a_1 b_0\rangle-\langle a_1 b_1\rangle\Big|\leq 2\sqrt{2}
\end{align}\]</span> which, as you see, is weaker by a factor <span class="math inline">\(\sqrt{2}\)</span>, so the correlations themselves can be stronger, although still bounded.</p>
</section>
<section id="final-remarks" class="level1">
<h1>Final remarks</h1>
<p>Quantum entanglement is indeed very unusual and consequential. There are many more wonders that it entails, please consult your favorite lecture notes for a non-exhaustive list. My current favorite are John Preskill’s <a href="http://theory.caltech.edu/~preskill/ph229/">lecture notes</a>. For a non-mathematical although technically very accurate discussion of entanglement see this artice by Frank Wilczek <a href="https://www.quantamagazine.org/entanglement-made-simple-20160428/">entanglement made simple</a>.</p>
<p>Any questions and suggestions are welcome, as this is my first blog demo.</p>



</section>

<div class="quarto-listing quarto-listing-container-default" id="listing-listing">
<div class="list quarto-listing-default">

</div>
<div class="listing-no-matching d-none">
No matching items
</div>
</div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="idnm/blog" data-repo-id="R_kgDOJWB1vg" data-category="General" data-category-id="DIC_kwDOJWB1vs4CVvR7" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>